{"pages":[],"posts":[{"title":"关于我","text":"2010年毕业后一直从事互联网/IT行业，曾就职于中兴通讯、金立通信、用友网络等知名企业。善于从事PHP后端开发、web前端开发、移动前端开发等岗位，现工作于点融科技。 本博客撰写目的主要是阐述作者对生活、工作、技术等方面的一些思考和感悟。写博客前前后后也有好几年了，由于种种原因以及写作水平有限导致博客更新比较慢。后面我将尽最大努力保证文章的更新频率，提升文章内容的质量。 本人对大自然充满好奇，喜欢通过旅游和摄影体验生活，丰富自我！专注于技术研究，喜欢折腾！常年混迹于UED、stackoverflow、Startup News、Hacker News、博客园、Github等。 通过以下更多方式了解我： 简历 微博 Github Twitter Facebook","link":"/2013/03/18/2013-03-18-about/"},{"title":"起点","text":"毕业三年有余，栖息于一线城市，在城市生活节奏的鞭笞下，让我感触颇多，生活、工作、爱情、友情都是那么的实现，勇于面对做好自己。 开博二年有余，第一次开博可以定位为“忆生活”——本着忆生活、忆往事、忆工作，第二次开博定位为“起点”——本着新生活、新工作、新发展、新方向，以正视生活、正视工作、敢于挑战、懂得分享。","link":"/2013/03/18/2013-03-18-bootstrap/"},{"title":"友情链接","text":"欢迎交流~（我的联系方式） 小剧客栈 » 90后天蝎男，前端工程师，全栈开发尝试者 阮一峰 » 阮老师，互联网知识传播者，技术大牛 张鑫旭 » 这么多年的坚持，值得佩服的博主","link":"/2013/03/18/2013-03-18-links/"},{"title":"h5前端开发规范文档","text":"“简洁易懂是一种美德。 为用户着想, 为服务器着想。—前端职业篇” “不是路不平，而是你不行，到底行不行，就看你停不停，只要你不停，早晚都得行。 —前端晋级篇 ” 规范目的 为提高团队协作效率, 便于后台人员添加功能及前端后期优化维护, 输出高质量的文档, 特制订此文档.本规范文档一经确认,前端开发人员必须按本文档规范进行前台页面开发.本文档如有不对或者不合适的地方请及时提出, 经讨论决定后方可更改. 基本准则 符合web标准, 语义化html, 结构表现行为分离, 兼容性优良. 页面性能方面, 代码要求简洁明了有序, 尽可能的减小服务器负载, 保证最快的解析速度. 文件规范 html, css, js, images文件均归档至本规范约定的目录中; html文件命名: 英文命名, 后缀.html,同时将对应界面设计稿放于同目录doc下PSD文件夹中, 若界面设计稿命名为中文, 请重命名与之对应的html文件同名, 以方便后端添加功能时查找对应页面; css文件命名: 英文命名, 后缀.css. 初始化样式reset.css, 共用base.css, 首页index.css, 其他页面依实际模块需求命名; Js文件命名: 英文命名, 后缀.js. 共用common.js, 其他依实际模块需求命名. HTML书写规范 文档类型声明及编码: 统一为html5声明类型; 编码统一为utf-8, 书写时利用IDE实现层次分明的缩进; 非特殊情况下样式文件必须外链到页面head标签之间;非特殊情况下JavaScript文件必须外链至页面底部; 引入样式文件或JavaScript文件时, 须略去默认类型声明. 引入JS库文件, 文件名仅包含库名称的压缩版, 比如zepto.js 源文件为zepto.source.js; 引入插件, 文件名格式为库名称+插件名称, 比如zepto.tabs.js 源文件为 zepto.tabs.source.js; 所有编码均遵循xhtml标准, 标签 &amp; 属性 &amp; 属性命名 必须由小写字母及下划线数字组成, 且所有标签必须闭合; 属性值必须用双引号包括; 充分利用无兼容性问题的html自身标签, 比如div, span, em, i, strong, label等等; 需要为html元素添加自定义属性的时候, 首先要考虑下有没有默认的已有的合适标签去设置, 如果没有, 可以使用须以”data-”为前缀来添加自定义属性（例如：data-ajaxUrl,data-infpage）, 避免使用”data:”等其他命名方式; 语义化html, 如标题根据重要性用h(同一页面只能有一个h1), 段落标记用p, 列表用ul,内联元素中不可嵌套块级元素; 尽可能减少div嵌套 书写链接地址时, 必须避免重定向，例如：href=”http://www.example.com/”, 即须在URL地址后面加上“/”； 在页面中尽量避免使用style属性,即style=”…”; 必须为含有描述性表单元素(input, textarea)添加label; 能以背景形式呈现的图片, 尽量写入css样式中; 重要图片必须加上alt属性; 给重要的元素和截断的元素加上title; 给区块代码及重要功能(比如循环)加上注释, 方便后台添加功能; 特殊符号使用: 尽可能使用代码替代: 比如 &lt;(&lt;) &amp; &gt;(&gt;) &amp; 空格( ) &amp; »(») 等等; 书写页面过程中, 请考虑向后扩展性; class &amp; id 参见 css书写规范. css书写规范 编码统一为utf-8; 协作开发及分工:组长根据项目需求或功能模块进行分工，每个成员都必须引入基本架构库进行开发; class与id的使用: id是唯一的并是父级的, class是可以重复的并是子级的, 所以id仅使用在大的模块上, class可用在重复使用率高及子级中; id原则上都是根据模块功能||通过规则命名的, 为JavaScript预留钩子的除外; 为JavaScript预留钩子的命名, 请以 J_起始, 比如: J_itemView, J_slider; class与id命名: 大的框架命名比如header/footer/wrapper/content/menu等.其他样式名称由 小写英文 &amp; 数字 &amp; - 来组合命名, 如in-tabs, in-form, mrt20等; 避免使用中文拼音, 尽量使用简易的单词组合; 总之, 命名要语义化, 简明化. 规避class与id命名(此条重要): 通过从属写法规避, 示例见d; 取父级元素id/class命名部分命名, 示例见d; 重复使用率高的命名, 请以统一代号加中划线起始, 比如in-; a,b两条, 适用于在2中已建好框架的页面, 如, 要在2中已建好框架的页面代码中加入新的div元素 css属性书写顺序, 建议遵循: 布局定位属性–&gt;自身属性–&gt;文本属性–&gt;其他属性. 此条可根据自身习惯书写, 但尽量保证同类属性写在一起. 属性列举: 布局定位属性主要包括: display &amp; list-style &amp; position（相应的 top,right,bottom,left） ＆ float &amp; clear ＆ visibility ＆ overflow； 自身属性主要包括: width &amp; height &amp; margin &amp; padding &amp; border &amp; background; 文本属性主要包括：color &amp; font &amp; text-decoration &amp; text-align &amp; vertical-align &amp; white- space &amp; 其他 &amp; content; 所列出的这些属性只是最常用到的, 并不代表全部; 书写代码前, 考虑并提高样式重复使用率; 充分利用html自身属性及样式继承原理减少代码量, 比如:这儿是标题列表2011-11-11 定义ul.list li{position:relative} ul.list li span{position:absolute; right:0}即可实现日期居右显示10. 样式表中中文字体名, 请务必转码成unicode码, 以避免编码错误时乱码;11. 背景图片请尽可能使用sprite技术, 减小http请求, 考虑到多人协作开发, sprite按模块制作;12. 使用table标签时(尽量避免使用table标签), 请不要用width/ height/cellspacing/cellpadding等table属性直接定义表现, 应尽可能的利用table自身私有属性分离结构与表现 , 如thead,tr,th,td,tbody,tfoot,colgroup,scope; (cellspaing及cellpadding的css控制方法:table{border:0;margin:0;border-collapse:collapse;} table th, table td{padding:0;}, base.css文件中我会初始化表格样式)13. 如何可以请少使用兼容;14. 用png图片做图片时, 要求图片格式优先考虑png-8格式后考虑png-24;15. 避免兼容性属性的使用, 比如text-shadow || css3的相关属性;16. 减少使用影响性能的属性, 比如position:absolute || float ;17. 必须为大区块样式添加注释, 小区块适量注释;18. 代码缩进与格式: 建议单行书写, 可根据自身习惯, 后期优化会统一处理; JavaScript书写规范 文件编码统一为utf-8, 书写过程过, 每行代码结束必须有分号; 原则上所有功能均根据XXX项目需求原生开发, 以避免网上down下来的代码造成的代码污染(沉冗代码 || 与现有代码冲突 || …); 库引入: 原则上仅引入icat库, 若需引入第三方库, 须与团队其他人员讨论决定（后备成熟库 zepto.js、underscore.js、xui.js、jquery.js）; 变量命名: 驼峰式命名. 原生JavaScript变量要求是纯英文字母, 首字母须小写且根据变量类型可定义为i、s、o, 如inum,sname,ophoto;另, 要求变量集中声明, 避免全局变量. 类命名: 首字母大写, 驼峰式命名. 如 Photos,Models; 函数命名: 首字母小写驼峰式命名. 如getName(); 命名语义化, 尽可能利用英文单词或其缩写; 尽量避免使用存在兼容性及消耗资源的方法或属性, 比如eval() &amp; Function; 后期优化中, JavaScript非注释类中文字符须转换成unicode编码使用, 以避免编码错误时乱码显示; 代码结构明了, 加适量注释. 提高函数重用率; 注重与html分离, 减小reflow, 注重性能. 图片规范 所有页面元素类图片均放入assets/img文件夹, 测试用图片放于pic文件夹; 图片格式仅限于gif || png || jpg; 命名全部用小写英文字母 || 数字 || _的组合，其中不得包含汉字 || 空格 || 特殊字符；尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, ad_banner.png || btn_login.png; 在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间; 尽量避免使用半透明的png图片(若使用, 请参考css规范相关说明); 运用css sprite技术集中小的背景图或图标, 减小页面http请求, 但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录下. 注释规范 html注释: 注释格式; css注释: 注释格式; JavaScript注释; 开发及测试工具约定开发环境：Sublime Text2.0（推荐） || Notepad++ || WebStorm || Dw || Crunch(Less开发工具) || Aptana || Vim Sublime Text2.0前端安装环境请参照：《Sublime Text搭建前端开发环境过程》; 工具使用原则 不可利用IDE的视图模式 ‘画’ 代码; 不可利用IDE生成相关功能代码, 比如Dw内置的一些功能js; 编码必须格式化, 比如缩进; 测试对象：chrome浏览器、UC浏览器、QQ浏览器、百度浏览器、公司浏览器以及Android原生浏览器; 其他规范 遵行标准、适应过程、写的更少、做的更多。 减小冗余代码, 书写所有人都可以看的懂的代码。 前端规范参考 yahoo前端优化性能规则 Google规范文档","link":"/2013/03/20/2013-03-20-frontend-tandard/"},{"title":"前端开发环境（ST2）搭建过程","text":"Sublime Text 2（简称：ST2）是一个实用又好用的编辑器，以其体积小、响应快、功能齐全、操作便捷、插件丰富、跨平台等特性，被前端人员的推崇为神器。 为了促进前端（团队）统一开发环境的正确搭建，现梳理一下我们产品业务中用到的一些插件，以便大家能快速搭建好ST2开发环境。 注：ST3版本硬性要求比较高，且与ST2兼容的插件比较少，帮暂不推荐升级。 准备工作下载对应版本的ST2:http://www.sublimetext.com/2 开始安装在windows环境下双击下载的ST2可执行文件即可安装。 ST2免费注册码下载 在linux环境下安装如下： 1.解压并修改ST2文件名 tar -xvf sublime_text_2.0.2.tar.bz2 mv Sublime\\ Text\\ 2/ sublime_text_2 2.移动到合适的位置，这里选择/usr/lib/ sudo mv sublime_text_2 /usr/lib/ 3.命令行（Terminal）下启动ST2 sudo ln -s /usr/lib/sublime_text_2/sublime_text /usr/bin/sublime 4.创建可使用的应用程序图标（可以放在Launcher下） sudo sublime /usr/share/applications/sublime.desktop 5.配置sublime.desktop文件 [Desktop Entry] Version=1.0 Name=Sublime Text 2 # Only KDE 4 seems to use GenericName, so we reuse the KDE strings. # From Ubuntu's language-pack-kde-XX-base packages, version 9.04-20090413. GenericName=Text Editor Exec=sublime Terminal=false Icon=/usr/lib/sublime_text_2/Icon/48x48/sublime_text.png Type=Application Categories=TextEditor;IDE;Development X-Ayatana-Desktop-Shortcuts=NewWindow [NewWindow Shortcut Group] Name=New Window Exec=sublime -n TargetEnvironment=Unity 安装ST2 packpage control 按Ctrl+`调出console 粘贴以下代码到底部命令行并回车 123import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) =&gt; 重启Sublime Text 2 如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功或者 Ctrl+Shift+p 调出的面板中搜索 install package 如果存在，则代表安装成功。 至此，ST2的安装已全部完成，下面我们要安装业务中所需要的插件。 安装sublime Text 插件的一般步骤=&gt; 按住 Ctrl+Shift+P=&gt; 在出现的输入框中输入 install=&gt; 选择 package control:install package 回车=&gt; 输入需安装的插件名称进行检索=&gt; 选中对应的插件，按回车=&gt; 稍定一会儿，插件正在安装中，注意右下角状态栏会显示正在连接的提示文字 前端Team需安装的插件 安装 compass 插件 安装 sass 插件 安装 zendcoding 插件 安装 YUI Compressor 代码压缩插件 安装 Sublime codeIntel 代码提示插件 安装 Alignment 代码等号对齐插件 安装 GBK Encoding Support 插件 安装 DocBlockr 插件 安装BracketHighlighter插件","link":"/2013/04/10/2013-04-10-how-to-install-sublime-text-2/"},{"title":"Node学习历险记（1）— 扬帆启航","text":"背景：毕业三年有余，栖息于一线城市，先后从事web前端开发、移动前端开发等相关工作，一次偶然的机会{2012年}面试了迅雷下载-前端开发工程师一职（没通过），开始知道Node的重要性，初步的去了解了Node的发展史以及应用场景，在参加腾讯H5沙龙、公司级培训、内部培训等相关活动时经常能听到Node字眼，似乎Node与H5（移动开发）一样爆发，是前端的福音。今年{2013年}借着项目以及学习计划开启Node学习之旅。 Node学习历险记采用游记的方式记录学习过程，由于文字功底弱，难免存在语句不通顺，标点错误等等一系列的语病，还望轻拍。^__^ 快速开始windows篇查看系统是32bit OR 64bit，DOS命令行下输入 wmic os get osarchitecture 1.下载Node.js官方Windows可执行程序： http://nodejs.org/download/ 2.下载MongoDB官方Windows可执行程序： http://www.mongodb.org/downloads 3.安装Node和MongoDB a.安装完成后，打开windows命令行（win+r）,输入cmd进行命令行模式 b.查看Node版本 node -v // 安装成功 v0.10.7 c.查看MongoDB版本 mongo --version // 安装成功 MongoDB shell version: 2.4.3 d.添加MongoDB系统变量 //切换到其他盘符查看显示 mongo --version 注：因为Node安装时默认会添加系统变量所以可全局访问，而MongoDB需手动添加系统变量。 4.MongoDB相关配置 详细的官方安装与配置（英文） 传送门 简单直白的配置方式(DOS下输入命令测试) 1.了解mongo 和 mongod 两个命令的作用 mongo:mongodb客户端命令，用于连接MongoDB服务器 mongod:mongodb服务器命令，用于启动和配置MongoDB服务器 2.开始配置和启动MongoDB a.在DOS下输入 mongod 回车，可以看到提示信息如下： D:\\&gt;mongod mongod --help for help and startup options Sun May 26 15:13:52.230 Sun May 26 15:13:52.243 warning: 32-bit servers don't have journaling enabled by default. Please use --journal if you want durability. Sun May 26 15:13:52.244 Sun May 26 15:13:52.422 [initandlisten] MongoDB starting : pid=5408 port=27017 d bpath=\\data\\db\\ 32-bit host=yihaner Sun May 26 15:13:52.423 [initandlisten] Sun May 26 15:13:52.423 [initandlisten] ** NOTE: This is a 32 bit MongoDB binary . Sun May 26 15:13:52.424 [initandlisten] ** 32 bit builds are limited to le ss than 2GB of data (or less with --journal). Sun May 26 15:13:52.424 [initandlisten] ** Note that journaling defaults t o off for 32 bit and is currently off. Sun May 26 15:13:52.424 [initandlisten] ** See http://dochub.mongodb.org/c ore/32bit Sun May 26 15:13:52.425 [initandlisten] Sun May 26 15:13:52.425 [initandlisten] db version v2.4.3 Sun May 26 15:13:52.426 [initandlisten] git version: fe1743177a5ea03e91e0052fb5e 2cb2945f6d95f Sun May 26 15:13:52.427 [initandlisten] build info: windows sys.getwindowsversio n(major=6, minor=0, build=6002, platform=2, service_pack='Service Pack 2') BOOST _LIB_VERSION=1_49 Sun May 26 15:13:52.427 [initandlisten] allocator: system Sun May 26 15:13:52.428 [initandlisten] options: {} Sun May 26 15:13:52.456 [initandlisten] exception in initAndListen: 10296 ********************************************************************* ERROR: dbpath (\\data\\db\\) does not exist. Create this directory or give existing directory in --dbpath. See http://dochub.mongodb.org/core/startingandstoppingmongo ********************************************************************* , terminating Sun May 26 15:13:52.457 dbexit: Sun May 26 15:13:52.458 [initandlisten] shutdown: going to close listening socke ts... Sun May 26 15:13:52.458 [initandlisten] shutdown: going to flush diaglog... Sun May 26 15:13:52.459 [initandlisten] shutdown: going to close sockets... Sun May 26 15:13:52.459 [initandlisten] shutdown: waiting for fs preallocator... Sun May 26 15:13:52.460 [initandlisten] shutdown: closing all files... Sun May 26 15:13:52.460 [initandlisten] closeAllFiles() finished Sun May 26 15:13:52.460 dbexit: really exiting now 很明显错误显示dbpath(\\data\\db\\)不存在（默认文件路径是C:\\data\\db），这里指定 db目录为E:\\mongodb\\data\\db log目录为E:\\mongodb\\log。 b.指定dbpath来启动MongoDB（在DOS下输入 mongod --dbpath E:\\mongodb\\data\\db） Sun May 26 15:26:25.423 [initandlisten] allocator: system Sun May 26 15:26:25.423 [initandlisten] options: { dbpath: &quot;E:\\mongodb\\data\\db&quot; } Sun May 26 15:26:25.460 [websvr] admin web console waiting for connections on po rt 28017 Sun May 26 15:26:25.460 [initandlisten] waiting for connections on port 27017 可以看到MongoDB已启动，等待客户端的连接。 我们发现这种启动方式每次最少要打开两个CMD窗口才可以进行操作，是否有更好的方法呢？ 如果MongoDB能够系统启动就好了，OK，可以把MongoDB添加到windows服务中。 c.方法如下： 1.在E:\\mongodb\\下创建mongod.conf配置文件，写入一下内容： logpath=E:\\mongodb\\log\\mongo.log //用于存放日志文件 dbpath=E:\\mongodb\\data\\db //用于存放数据库文件 2.执行以下命令 mongod --config E:\\mongodb\\mongod.conf --install 3.通过DOS命令行操作Mongodb net start MongoDB //启动服务 net stop MongoDB //停止服务 4.在命令行下执行 mongo 连接数据库， 连接成功后输入： show dbs; admin 0.0625GB local 0.03125GB test 0.0625GB 相关类似的信息说明配置成功，客户端连接MongoDB成功，现在就可以直接操作数据库啦。 至此，Node学习历险记 -《快速开始》篇到此告一段落，如有表述不正确的地方还望指正，我将及时更正。 欢迎加入交流群：322794303","link":"/2013/05/20/2013-05-20-getting-start-nodejs/"},{"title":"nodemailer使用过程中发现的一些问题","text":"##nodemailer使用过程中发现的一些问题 在实现Node.js开发指南中提到的microblog后，想加入邮件功能模块，通过各方的了解，最终选择了nodemailer。根据nodemailer官网的使用方法介绍，可以很轻松的实现邮件发送功能，可是当你根据自己的想法去使用nodemailer时会遇到一些问题，以下详细的介绍nodemailer的使用以及遇到的问题的一些思考。 安装nodemailer1npm install nodemailer 引入nodemailer模块1var nodemailer = require('nodemailer'); nodemailer实例123456789101112131415161718192021222324var nodemailer = require('nodemailer');var transport = nodemailer.createTransport('SMTP', { service: 'qq', //use well known service auth: { user: 'hxrealm@qq.com', pass: '123456' }});var data = { form: 'han.yi &lt;yihan.sz@qq.com', to: 'tomail@gmail.com,tomail2&lt;tomail2@gmail.com&gt;', subject: 'Hello world', text: 'Hello world, I am a test mail!', html: '&lt;b&gt;Hello world, I am a test mail!&lt;/b&gt;'};transport.sendMail(data, function(err, res){ if (err) { console.log(err); } else { console.log('Message sent: ' + res.message); }}); 运行以上实例会产生以下几种情况： 1.当user和pass正确时，采用Gmail SMTP方式邮件发送成功。（Gmail只验证用户是否通过认证，不做其他格式要求） 2.当user和pass正确时，采用QQ SMTP方式邮件发送失败。（QQ邮件服务器验证用户是否通过认证、用户与收件人是否一致，同时格式须正确。） 1234{ [SenderError: Mail from command failed - 501 mail from address must be same as authorization user] name: 'SenderError', data: '501 mail from address must be same as authorization user' } 3.当user和pass正确时，采用126、163 SMTP方式邮件发送失败。（网易邮件服务器验证用户是否通过认证、用户与收件人是否一致，同时验证邮件格式是否正确） 1234{ [SenderError: Mail from command failed - 550 Invalid User c6b4f4d2-2f21-4de3-8985-68b589eab3d1] name: 'SenderError', data: '550 Invalid User c6b4f4d2-2f21-4de3-8985-68b589eab3d1' } 当用户的邮件格式不正确，或者收件人错误时，返回提示信息都没有QQ邮件服务精确 为了明确的知道邮件发送过程，我通过windows DOS命令telnet smtp连接邮件服务器，测试邮件发送情况，同时找到了得出以上结论。 nodemailer的几点说明 官网的实例大部分都是采用定义service: “Gmail” 的SMTP发送邮件。(基中service是指定义好的接口，包含提供SMTP服务的邮件服务商列表。文件路径为：node_modules/nodermailer/lib/wellknown.js) 2.nodemailer-&gt;service默认国内的邮件服务商只提供QQ的配置，如果需要使用其他邮件服务商的SMTP可以打开wellknown.js文件进行修改。 1234567891011121314151617181920文件路径：node_modules/nodermailer/lib/wellknown.js&quot;126&quot;:{ transport: &quot;SMTP&quot;, host: &quot;smtp.126.com&quot;, port:465, secureConnection: true, requiresAuth: true, domains: [&quot;126.com&quot;]},&quot;163&quot;:{ transport: &quot;SMTP&quot;, host: &quot;smtp.163.com&quot;, port:465, secureConnection: true, requiresAuth: true, domains: [&quot;163.com&quot;]}以上SMTP格式也可以在nodemailer.createTransport参数传递过程中指定。 参考资料 nodemailer官网 http://www.nodemailer.com/ win7下开启telnet http://zhidao.baidu.com/question/316035780.html telnet smtp发送邮件 http://www.cnblogs.com/rootq/articles/1320266.html","link":"/2013/05/29/2013-05-29-how-to-use-node-middleware-nodemailer/"},{"title":"金立招聘移动前端开发工程师（长期有效）","text":"工作内容与职责： 能快速熟悉前端标准组件，并能利用组件灵活布局页面和实现简单的效果。 能高效完成布置的任务，并与后端开发人员密切的配合。 在开发过程中，能给出一定的方案来实现前后端交互。 任职资格： 精通html+css布局，能熟练手写规范的代码。 精通jquery、YUI等常用的框架，熟悉基本的原生javascript。 熟悉web标准和网站性能优化。 熟悉html5、css3等前沿的前端技术，有成功案例的优先。 熟悉webkit内核浏览器，有相关经验的优先。 至少熟悉一种后端语言如php等。 两年以上的前端开发经验，计算机相关专业。 备注：工作地点深圳、北京两地均招。 PS:我们提倡快乐工作，快乐生活。因为只有生活快乐，工作才快乐。我们提倡自主学习，因为最好的老师就是你自己。我们提倡分享精神，因为分享可以让大家一起进步。 不走繁琐的流程，直接内推，有兴趣的朋友就把简历发送至：yihan.sz@qq.com","link":"/2013/06/10/2013-06-10-get-job-at-gionee/"},{"title":"lookitui 移动端的通用样式组件库","text":"lookitui 是一个移动端的通用样式组件库。为了提升协同开发的效果，采用compass扩展插件的方式存在。 查看DEMO lookitui 的安装 gem install lookitui --pre lookitui的结构 @import &quot;lookitui/vars&quot;; //变量的配置 @import &quot;lookitui/reset&quot;; //reset.css @import &quot;lookitui/func&quot;; //通用的函数库 @import &quot;lookitui/slider&quot;; //幻灯片组件 @import &quot;lookitui/refresh&quot;; //加载组件 @import &quot;lookitui/form&quot;; //表单样式 @import &quot;lookitui/box&quot;; //区块样式 @import &quot;lookitui/button&quot;; //按钮样式 @import &quot;lookitui/list&quot;; //列表样式 @import &quot;lookitui/loading&quot;; //loading样式 @import &quot;lookitui/toolbar&quot;; //工具栏组件 @import &quot;lookitui/gotop&quot;; //返回顶部组件 @import &quot;lookitui/tab&quot;; //Tab切换组件 lookitui的引用 12345678// 1.引用所有模块 @import &quot;lookitui/all&quot;; // 2.引用单一模块 @import &quot;lookitui/form&quot;; // 例如：引用表单模块（Form最新版本） // 3.引用固定版本的独立模块 @import &quot;lookitui/form/0.1/form&quot;; // 例如：引用表单模块（Form最新版本） 注：引入独立模块是必须先引入lookitui核心模块。 查看DEMO github访问地址：http://github.com/hxrealm/lookitui/","link":"/2013/06/13/2013-06-13-quick-start-lookitui/"},{"title":"Ubuntu 12.0.4下安装Nodejs","text":"准备工作1sudo apt-get install g++ curl libssl-dev apache2-utils 安装方式（一）：git clone12sudo apt-get install git-coregit clone git://github.com/ry/node.git 安装方式（二）： 源码安装123wget http://nodejs.org/dist/v0.10.13/node-v0.10.13-linux-x64.tar.gzmv node-v0.10.13-linux-x64.tar.gz node-linux-x64.tar.gztar -zxvf node-linux-x64.tar.gz 编译和安装Node1234cd your-node-current-folder./configuremakesudo make install 查看是否安装成功1node -v OR node -version //查看Node.js当前的版本 Node运行hello world在主文件夹创建hello.js,编辑以下文本： 12345678var http = require('http');http.createServer(function(req, res){ res.writeHead(200, {'Content-Type': 'text/plain'});res.end('Hello world!');}).listen(3000,'127.0.0.1');console.log('Server running at http://127.0.0.1:3000/') 在命令行中运行1node hello.js 打开浏览器，输入http://127.0.0.1:3000/，可以看到屏幕上显示&quot;Hello world!&quot;。","link":"/2013/07/12/2013-07-12-ubuntu-install-node-js/"},{"title":"在IT行业获得成功，你只需一项技能(转载)","text":"能同时使用五种编程语言（包括一种机器语言）？不是。 项目管理能力，再高就是获得PMP认证？也不是。 超强的口才和书面沟通能力，正如工作职位中描述的那样？这不是痛点，但可以学习。 我曾经与最好的IT专业人士一起工作，他们都具有超强的问题解决能力。 问题解决能力？对，正是它。 该图是否让你联想到你的机房？ 我们会不定期遇到很多问题，诸如从“我的电脑为什么锁住了”到“服务器为什么这么慢”等一系列问题。如何解决这些问题，是区分优秀专业人士和一般专业人员的标准。 问题解决方法学 在中学期间，我曾接触过该科学方法。过程是这样的： 1.对问题进行明确的描述； 2.做出假设； 3.进行预测； 4.验证假设。 5.分析结果。 该方法论可以应用到我所遇到的问题之上吗？当然可以。 对问题进行明确的描述——通常，会很多问题要求你解决你。如“服务器为什么这么慢？”“我为什么连接不上数据库？”“该报告为什么运行超时？” 做出假设——前天晚天，可能在服务器或SQL Serve上打了补丁。可能是网线没有插好。也可能是开发者改了存储程序中的一行代码。列出可能影响系统产生该问题的原因，并按该列表一一测试。 进行预测——猜猜结果是怎样的。如果是一个你之前曾遇到的问题/错误，接下来如何处理，你心里就十分清楚了。如果是一个新问题，利用之前的经验和推断技巧，去判定哪些改变导致了系统产生问题。 验证——制定一个计划，进行一处修改，然后检查问题是否解决。不要一次做出三处及以上修改， 这样不容易确定是哪处改变修复了该问题——一次只修改一处。要明白系统正常运行是怎样的。如果查询很慢，要了解问题发生之前性能是怎样的，问题发生时性能是怎样的，什么样的性能是可以接受的。明确的检验指标很重要。你必须能够测定出问题是否得到改善，是否保持原样，还是变得更加糟糕。 分析结果——对指标进行验证。你是否获得你期望的结果？如果是，问题解决了吗？如果不是，根据你的列表，下一项检测是什么？继续根据列表一一检测并分析，直到问题解决。 任何人都可以做到 它不要求你具有计算机科学博士学位，也不要求化学硕士学位。只需要你始终如一的对待每一个问题。需要具有好奇心，具有查看模式的能力。 在实践中，该方法会越来越简单。经常锻炼解决问题的能力，你将成为长优秀的IT专家，并从众多IT人中脱颖而出。 原文来自： Brent Ozar","link":"/2013/07/07/2013-07-07-owner-one-skill-in-it-industy/"},{"title":"前端系列Javascript“小题大做”","text":"背景在内部分享会上多次听到后端同学希望前端同学能分享一些JS的基础知识和技巧。一直以来都忙于各种事情，好久没有关注Javascript基础内容，借今天@valleykid(ICAT作者)在群里发的一个JS小题来揭开JavaScript精典问题集的大门。 以后将持续收集和更新JavaScript各种代表性“小题”，并做出详细的解答。 情节1.运行下面的代码，输出的结果是？ 123456789var a = 10;sayHi();function sayHi(){ var a = a + 10; alert(a); return a;}alert(a);alert(sayHi()+10); 答案是NaN, 10, NaN, NaN 分析：第一次的NaN，是因为var a在函数内部声明，js解析器遇到会提前解析，并把a的值设为undefined，此时的a已经在内部的作用域里找到了，就不用沿着作用域链向上找了，所以全局a不会影响函数内部的a，很自然的结果应该为： 第一次：undefined+10 //输出结果：NaN 第二次：因为局部的a在函数执行完销毁，在执行的时候也没对a造成影响，所以全局a保持其初值10 //输出结果：10 以下类推…… 持续更新中… 结局由于个人能力有限，对问题的收集与解答不正确的地方在所难免，共同学习，共同进步，欢迎指正。","link":"/2013/07/17/2013-07-17-javascript-question-collection/"},{"title":"Ubuntu 12.04下Sublime Text 2的详细安装与破解过程","text":"记得之前也写过一篇文章《前端开发环境（ST2）搭建过程》，主要讲不同环境下安装的过程以及当时团队前端开发环境搭建过程（涉及到业务需求的一些组件、外部工具等等）。本篇文章意在详细讲解Ubuntu 12.04（与版本无关）下安装破解ST2的过程。 使用ST2已有很久时间了，一直认为它是“最好的一款前端开发工具”，喜欢它体积小、速度快、外观简单、代码语法高亮清晰、插件丰富、安装简单。实际上ST2是一款共享软件，收费（59刀）但可以永久免费试用的跨平台的编辑神器。好了，不多在这里扯蛋啦，有讲的不好、或者不清晰的地方还请指正。 为什么不使用ST3呢？ （答：ST3改动很大，不能与ST2兼容，因此没有丰富的插件，后期可以进行尝试安装。） 一、ST2安装流程:官网下载安装包官网地址：http://www.sublimetext.com/2 ST2目前是2.0.2版，由于软件源并非默认就存在，所以apt-get install是无法下载到的。官网也是提供直接的下载包，linux下是.bz2的文件。文件不大，才5M多一点。 解压放置解压并不难，随便找个目录解压就行，但考虑到后面要能在命令行下方便的快速启动，推荐解压到/usr/lib/目录下，我用的方法是先解压后搬移，命令如下： tar -xvf Sublime\\ Text\\ 2.0.1.tar.bz2 //解压到当前目录 mv Sublime\\ Text\\ 2 /usr/lib/ //移动到／usr/lib／目录下 sudo mv Sublime\\ Text\\ 2 sublime-text-2 //修改文件名为sublime-text-2 其中的\\为转义符 这样做是因为$PATH这个环境变量自动涵盖了/usr/lib这个目录，不用专门去修改环境变量。 然后键入： ln -s /usr/lib/sublime-text-2/sublime_text /usr/bin/st2 这行命令是在/usr/bin/目录下建立一个名为st2链接，这样后面可以比较方便的用命令行启动这个编辑器。其中st2这个名字是自行定义的，用户可以定义的更加简单方便。 这个时候应该已经安装结束了，可以用st2来打开一个文件试试。 侧边条LaunchBar设置由于并非安装，缺少Ubuntu桌面运行的一些基本配置，比如不能将它加入桌面侧边的启动器，这个和通过软件安装中心安装的程序不太一样。要做到这一点，需要增加一个配置文件，放在/usr/share/appliations/路径下，比如增加sublime.desktop，文件内容如下： [Desktop Entry] Version=1.0 Name=Sublime Text 2 # Only KDE 4 seems to use GenericName, so we reuse the KDE strings. # From Ubuntu's language-pack-kde-XX-base packages, version 9.04-20090413. GenericName=Text Editor Exec=st2 Terminal=false Icon=/usr/lib/sublime-text-2/Icon/48x48/sublime_text.png Type=Application Categories=TextEditor;IDE;Development X-Ayatana-Desktop-Shortcuts=NewWindow [NewWindow Shortcut Group] Name=New Window Exec=st2 -n TargetEnvironment=Unity 保存后给予可执行属性即可。 FAQ 如果一定希望通过apt-get install来安装，可以如下来做： sudo add-apt-repository ppa:webupd8team/sublime-text-2 sudo apt-get update sudo apt-get install sublime-text-2 关于package control以及前端插件的安装可以查看我之前写的文章《前端开发环境（ST2）搭建过程》。 二、Linux下ST2破解的过程 首先查看一下ST2安装路径(推荐安装的路径是：／usr/lib/sublime-text-2)，然后用vim打开sublime_text文件 ＃ whereis sublime-text-2 输出结果： ＃ sublime-text-2:/usr/bin/sublime-text-2 /usr/lib/sublime-text-2 /usr/bin/X11/sublime-text-2 －－这里是两条信息，第二个/usr/前面有一个空格的 然后，进入第一个路径下，查看有哪些文件，输入： # cd /usr/lib/sublime-text-2/ # ls 会列出的文件信息有： Icon lib PackageSetup.py Pristine Packages sublimeplugin.py sublimetext 然后我们用vim打开这个文件（如果没有装vim 输入：# sudo apt-get install vim 安装） #sudo vim /usr/lib/sublime-text-2/sublime_text 将文件转成十六进制形式。vim中输入 :%!xxd 在vim中定位至“Thanks”文字附近。 :/Thanks 接着查找数字串“3342” :/3342 找到一处3342的地方大致是这个样子 ……4333 3342 3032……. 将这里的3342 改为3242,在vim中输入 :s/3342/3242 将文件转换回去。 :%!xxd -r 保存文件、退出。 :wq 打开程序，去help-enter licence 里贴进去通过程序算出来的Licence，OK 成功了。 —–BEGIN LICENSE—– China Unlimited User License EA7E-2861 BE67D2175D3569FDAB9EB5340FAD2822 E7B56B3397A76AA9FBE8AC3D3C65918B DFC28F2EA158140D9E07853D594818EB 3A237B2E8E98ED257C269548F50EDA34 EF0C7F72D8917DB538A0245E46BFD6B1 85F4EDE331F253530ED67A5C19E92399 04C5F4A1AF4AF3DB5EC49C1FEE17CA76 7E369F8AAE4AC6C6E756B5882E1608B9 —–END LICENSE—– 补充说明：Sublime Text 2是一款轻量型的编辑器，但功能却远远超过了我的预期，让我很满意的一点是速度快，搜索，跳转等都相当快，另外还有多重选中的功能，这个也挺实用的，总之这款编辑器可以尝试一下，是个不错的选择。","link":"/2013/08/10/2013-08-10-ubuntu-install-sublime-text-2/"},{"title":"ST2打开.scss文件时自动生成并打开.dump文件的BUG","text":"今天同事用ST2打开.scss项目文件时，出现自动生成并打开一个.dump文件，而且文件中的代码不再高度显示，分析如下： 1..dump是什么文件？（系统内存中存储的临时文件）。 2.打开.scss文件时生成.dump文件，这是为什么？（.scss需要编译成.css文件，同时存在编码问题）。 3.什么影响打开.scss文件时才会生成.dump文件？（ST2安装的插件、插件文件损毁）。 通过以上分析，我们开始Remove Package中可能引起问题的插件例如SublimeOnSaveBuild、PyV8,重启ST2发现问题依然存在，后面通过搜索相关资料发现有类似问题的答案，重新查看了ST2中安装的插件发现安装了GBK Encoding Support，移除该插件后，重新打开.scss文件，代码正常高度显示。 疑问：GBK Encoding Support一直都在使用，为什么之前没有出现这样的问题呢？ 1.GBK Encoding Support 插件对GBK存在不稳定。 2.通过SVN版本管理，某一方没有安装GBK Encoding Support插件，而已一方安装了GBK Encoding Support插件。 感谢 [凌毅] 提供修改版的 GBK Encoding Support，支持语法高亮。 下载地址：http://pan.baidu.com/share/link?shareid=174741&amp;uk=2534294120 使用方法：下载 GBK Encoding Support.sublime-package 文件 替换 SublimeText2\\Pristine Packages 下的GBK Encoding Support.sublime-package 文件，重启ST2就可以了。","link":"/2013/08/02/2013-08-02-sublime-text-open-dump-bug/"},{"title":"JS判断客户端是否为手机移动设备","text":"12345678910111213141516171819function is_mobile(){ var ua = navigator.userAgent, isMobile = false; var ma = [&quot;240x320&quot;,&quot;acer&quot;,&quot;acoon&quot;,&quot;acs-&quot;,&quot;abacho&quot;,&quot;ahong&quot;,&quot;airness&quot;,&quot;alcatel&quot;,&quot;amoi&quot;,&quot;android&quot;,&quot;anywhereyougo.com&quot;,&quot;applewebkit/525&quot;,&quot;applewebkit/532&quot;,&quot;asus&quot;,&quot;audio&quot;,&quot;au-mic&quot;,&quot;avantogo&quot;,&quot;becker&quot;,&quot;benq&quot;,&quot;bilbo&quot;,&quot;bird&quot;,&quot;blackberry&quot;,&quot;blazer&quot;,&quot;bleu&quot;,&quot;cdm-&quot;,&quot;compal&quot;,&quot;coolpad&quot;,&quot;danger&quot;,&quot;dbtel&quot;,&quot;dopod&quot;,&quot;elaine&quot;,&quot;eric&quot;,&quot;etouch&quot;,&quot;fly &quot;,&quot;fly_&quot;,&quot;fly-&quot;,&quot;go.web&quot;,&quot;goodaccess&quot;,&quot;gradiente&quot;,&quot;grundig&quot;,&quot;haier&quot;,&quot;hedy&quot;,&quot;hitachi&quot;,&quot;htc&quot;,&quot;huawei&quot;,&quot;hutchison&quot;,&quot;inno&quot;,&quot;ipad&quot;,&quot;ipaq&quot;,&quot;ipod&quot;,&quot;jbrowser&quot;,&quot;kddi&quot;,&quot;kgt&quot;,&quot;kwc&quot;,&quot;lenovo&quot;,&quot;lg &quot;,&quot;lg2&quot;,&quot;lg3&quot;,&quot;lg4&quot;,&quot;lg5&quot;,&quot;lg7&quot;,&quot;lg8&quot;,&quot;lg9&quot;,&quot;lg-&quot;,&quot;lge-&quot;,&quot;lge9&quot;,&quot;longcos&quot;,&quot;maemo&quot;,&quot;mercator&quot;,&quot;meridian&quot;,&quot;micromax&quot;,&quot;midp&quot;,&quot;mini&quot;,&quot;mitsu&quot;,&quot;mmm&quot;,&quot;mmp&quot;,&quot;mobi&quot;,&quot;mot-&quot;,&quot;moto&quot;,&quot;nec-&quot;,&quot;netfront&quot;,&quot;newgen&quot;,&quot;nexian&quot;,&quot;nf-browser&quot;,&quot;nintendo&quot;,&quot;nitro&quot;,&quot;nokia&quot;,&quot;nook&quot;,&quot;novarra&quot;,&quot;obigo&quot;,&quot;palm&quot;,&quot;panasonic&quot;,&quot;pantech&quot;,&quot;philips&quot;,&quot;phone&quot;,&quot;pg-&quot;,&quot;playstation&quot;,&quot;pocket&quot;,&quot;pt-&quot;,&quot;qc-&quot;,&quot;qtek&quot;,&quot;rover&quot;,&quot;sagem&quot;,&quot;sama&quot;,&quot;samu&quot;,&quot;sanyo&quot;,&quot;samsung&quot;,&quot;sch-&quot;,&quot;scooter&quot;,&quot;sec-&quot;,&quot;sendo&quot;,&quot;sgh-&quot;,&quot;sharp&quot;,&quot;siemens&quot;,&quot;sie-&quot;,&quot;softbank&quot;,&quot;sony&quot;,&quot;spice&quot;,&quot;sprint&quot;,&quot;spv&quot;,&quot;symbian&quot;,&quot;tablet&quot;,&quot;talkabout&quot;,&quot;tcl-&quot;,&quot;teleca&quot;,&quot;telit&quot;,&quot;tianyu&quot;,&quot;tim-&quot;,&quot;toshiba&quot;,&quot;tsm&quot;,&quot;up.browser&quot;,&quot;utec&quot;,&quot;utstar&quot;,&quot;verykool&quot;,&quot;virgin&quot;,&quot;vk-&quot;,&quot;voda&quot;,&quot;voxtel&quot;,&quot;vx&quot;,&quot;wap&quot;,&quot;wellco&quot;,&quot;wig browser&quot;,&quot;wii&quot;,&quot;windows ce&quot;,&quot;wireless&quot;,&quot;xda&quot;,&quot;xde&quot;,&quot;zte&quot;,&quot;GiONEE&quot;,&quot;GiONEE-&quot;]; for (var i = 0, lens = ma.length; i &lt; lens; i++) { if (ua.indexOf(ma[i]) &gt; -1) { isMobile = true; break; } } return isMobile;}if(is_mobile() === true){ document.write(navigator.userAgent + '&lt;br&gt;'); document.write('mobile access!'); //location.href = &quot;http://blog.hanyi.pro/&quot;} else { document.write(navigator.userAgent + '&lt;br&gt;'); //document.write('pc access!'); } 参考：http://levi.cg.am/?p=2214","link":"/2013/09/06/2013-09-06-media-your-device-by-javascript/"},{"title":"用心感受生活，用视觉鞭笞思想","text":"最近有些迷茫，不知道自己做了些什么，一下子感觉心里很空虚，每天看的最多的是网易新闻，似乎奇葩事情已不是在那么的奇怪，只是没有关注或者没有报道出来而已。看的多了，想的也就多了，久违的周公近期在我的心灵小站活动频频，难道周公不去光顾那些“美少女”了吗?我惊叹呼！ 以前大家都教我用心感受生活，总能有所收获。今天我不经意的要问：“不专注的心还能感受生活吗？”，迷茫的时刻，我发现自己不在专注，感觉很多东西要去多，这个弄弄那个弄弄，似乎还很忙的样子（其实什么都没有做成），连冷静思考的时间都没有似的。 今天又是大周六，头脑风暴（3分钟）自由演讲，为了给自己充足的时间时间去头脑风暴，我选择了最后一个演讲。从心里回顾一下近期的工作以及生活等等方面，我确定了主题“耳听为虚，眼见为实，用心感受生活，用视觉鞭笞思想”，用它来概括这次涉及到的话题“梦、健康、人生价值、无奈生活”。 冷静思考为了“梦、健康、人生价值、无奈生活”。 中国梦 － 个人梦 健康 － 奋斗 人生价值 － 努力 无奈生活 － 人生选择","link":"/2013/09/07/2013-09-07-feeling-in-your-heart/"},{"title":"记忆人生，勿轻意忘记","text":"你的人生，你的日子，不要放弃，不要忘记！ 今年是一个特殊的年份; 今月是一个值得记忆的月份; 今日是一个难忘的日子; 今时是一个激动的时刻; 我的本命年我的生日！ 人生的本命年百度百科解释：十二年—遇的农历属相所在的年份，俗称属相年。在传统习俗中，本命年常常被认为是一个不吉利的年份。“本命年犯太岁，太岁当头坐，无喜必有祸”的民谣是关于本命年不甚吉利的最好写照。 虽然在本命年的开始，我也失去了无法忘却的记忆，但是本命年的不利真的是天命吗？其实不然，个人认为都是自己处事的不严谨，造成了人生的插曲。呵呵，还是不要对这些进行评论啦！ 本命年无论是好还是坏，我们都不能忘记，因为人生中能有几个本命年呢。 特殊的九月九月是一个秋高气爽的季节; 九月是一个开始大声高歌a、o、e的季节 ——— 小学; 九月是一个开始为理想奋斗的季节 ——— 初中、高中; 九月是一个开始进入梦想殿堂的季节 ——— 大学; 九月也是爸爸、姐姐和我出生的季节。 难忘的今天今天是偷看十五的月亮圆不圆的日子; 今天是一个月的中旬的日子; 今天是值得记忆的日子; 生日快乐！","link":"/2013/09/15/2013-09-15-snake-year-in-my-life/"},{"title":"Ubuntu下通过Heroku部署Node.js应用程序","text":"自从写第一个Node Microblog web应用到现在也很长时间了，虽然后面也写了几个Node小工具，但是一直都是基于本地环境。虽然之前也有尝试在SAE、NAE(已停止维护)、BAE上部署Node应用程序，但由于种种原因，最终也只是一个尝试，没有成功部署，在此还是推荐几家PaaS平台： Heroku(信赖Git+Foreman) Cloud Foundry(依赖vmc+ruby+rubyGems) Nodester(被AppFog收购) AppFog 可根据自己的喜好与对PaaS不同平台的了解，选择适合的平台，本文选择Heroku来部署。 Heroku部署Node.js应用程序的步骤如下： 1.访问 https://id.heroku.com/signup/www-header ，网站会要求用户输入电子邮件地址。 2.Heroku注册，一旦成功输入电子邮件地址，网站会邀请你检查邮件，邮件中有确认链接。 3.打开电子邮件，进入所提供的Heroku链接，点击链接会邀请你输入密码。 4.按照 https://devcenter.heroku.com/articles/getting-started-with-nodejs 中的指南，首先安装Heroku工具条。它提供了能让我们将站点部署到Heroku的命令行工具。 5.访问 https://toolbelt.heroku.com/ ，选择适用于自己平台的安装方式，这里我选择的是 Debian/Ubuntu。 安装Heroku命令行工具 6.Heroku toolbelt 安装完成后，现在就可以登录账号，在命令行模式下输入 $ heroku login //输入heroku注册的账号信息 Enter your Heroku credentials. Email: test@gmail.com Password (typing will be hidden): //如果是第一次登录，heroku会为你生成一个SSH公共密钥， //以此来管理对服务的访问，可在heroku账号设置中查看 Could not find on existing public key. Would you like to generate one? [Yn] Generating new SSH public key. Uploading ssh public key ~/.ssh/id_rsa.pub 7.至此，Heroku 环境配置己完成，可以准备部署到Heroku服务器啦！ 8.检查程序入口文件中服务器端口设置是否正确。 //Express 默认端口配置 var port = process.env.PORT || 3000; //由于heroku会随机分配端口，因此不用指定固定端口 app.listen(port); 9.Heroku的进程管理工具Foreman需要通过Procfile文件来声明应该默认启动的文件，因此需在应用程序根目录添加一个名为Procfile的文件，如下所示： //进入应用程序根目录，声明启动的文件 $ echo &quot;web: node app.js&quot; &gt; Procfile //通过Foreman启动应用程序 $ forman start 14:06:24 web.1 | started with pid 5105 14:06:26 web.1 | Express server listening on port 5000 10.Foreman启动成功后，可以通过本地访问应用程序，最现只差上传应用程序到Heroku。 //在应用程序package.json文件中指定engines &quot;engines&quot;: { &quot;node&quot;: &quot;0.10.x&quot;, &quot;npm&quot;: &quot;1.2.x&quot; } //检查应用程序package.json中的信赖文件是否安装 $ npm install //通过Git添加应用程序到仓库，并上传到Heroku $ git init //创建git仓库 $ git add . //添加文件到仓库 $ git commit -m 'upload to heroku' //提交文件到仓库 $ heroku create nodetest --stack ceder //在heroku中建立nodetest应用 $ git push heroku master //提交应用程序到heroku的master主干 11.如果一切正常，可以通过Heroku分配的二级域名访问应用程序，例如 http://nodetest.herokuapp.com12.Heroku支持自定义域名绑定，操作如下： //在以有的域名中添加子域名并指定DNS为Heroku分配的二级域名 //以www.nodetest.com为例,添加到heroku自定域名中 $ heroku domains:add www.nodetest.com //查看域名信息 $ heroku domains === nodetest Domain Names nodetest.herokuapp.com www.nodetest.com //通过命令行打开并访问应用程序 $ heroku open 参考文档 http://blog.sina.com.cn/s/blog_6d0cbb0301019jor.html http://blog.longwin.com.tw/2011/04/ssh-failure-sign-key-2011/ http://blog.csdn.net/ithomer/article/details/7529022 http://www.2cto.com/kf/201201/116097.html http://ux.etao.com/posts/799","link":"/2013/09/17/2013-09-17-ubuntu-heroku-build-node-app/"},{"title":"Ubuntu下vim安装markdown插件","text":"Markdown出来也有很长时间了，网上也有很多关于Markdown的语法介绍以及使用说明，如果还不知道什么是Markdown,可以查看这篇文章。写这篇文章的初衷只为了记录在Windows系统与Ubuntu系统下使用markdown的一些个人感受。 Markdown in windowsSublime text 2由于个人偏爱使用Sublime text 2（以下简写为ST2）进行编码,所以一般都偏向安装ST2的插件，在这里选择的是Markdown和Markdown Preview，Markdown主要是markdown的语法高度，Markdown Preview主要是文档预览（非实时的预览）。也许是更加喜爱像Dreamweaver那样的可视化操作，因此搜索后发现了MarkdownPad。 MarkdownPad相比使用ST2来讲，MarkdownPad可以实时预览，多文件切换也很流畅，但不喜爱它默认的markdown语法高度的颜色以及有限的免费版功能，因此尝试了使用MdCharm。 MdCharm相比ST2与MarkdownPad来讲，MdCharm是我个人比较喜爱的一款Markdown编辑器，不仅启动速度快、语法高亮的颜色以及渲染的文档都不错，所以在写Blog的时候使用非常的方便。 由于开发环境切换到Ubuntu后,一般都是使用 gedit 和 vim 进行文件的查看与编写，所以在此记录vim下配置markdown以及markdown to wordpress。 Markdown in ubuntu在这里我也不需要重复造轮子，可以查看以下链接： 在vim中设置markdown语法高亮 使用vim和markdown撰写blog并发布到wordpress 注意：操作完成后，重新打开vim。 参考文档： http://wowubuntu.com/markdown/ http://daringfireball.net/projects/markdown/basics http://zh.wikipedia.org/wiki/Markdown","link":"/2013/09/18/2013-09-18-ubuntu-vim-install-markdown-plugin/"},{"title":"精彩国庆，娱乐人生","text":"今年的国庆假期可以简单的概括为“精彩国庆，娱乐人生”！ 没有加班，没有旅行，也没有回家，只有娱乐。有点遗憾的是没有及时的打电话回家，让爸妈担心啦！ 国庆的娱乐-游戏LOL,虽然国庆大部分时间都是在游戏中渡过的，可能关心我的朋友们在心里都认为我现在“颓废”了,其实我很清楚，自己在做什么，应该做什么。有时候感觉人很奇怪，有太多的想法，有太多的事，有太多的……,我记得某次分享中提到“用心感受生活，用视觉鞭笞思想”的主题，我想与工作了几年了解了一些国外的文化以及公司文化等等，让我视野开阔了，接受了一些新的思想，有了“丰富”的阅历。 今年的国庆让我有以下的收获： 1.冷静思考了近期的规划。 2.学会了主动分享以及分享的价值。 3.奉献与回报的意义。 4.团队精神的重要性。 5.愉快的心情。","link":"/2013/10/07/2013-10-07-happy-national-day/"},{"title":"总结在金立工作的一年","text":"2012年9月下旬加入金立(GiONEE),从事移动互联网H5研发工作。 在金立的这一年，首先要感谢 @rainkid 和 @valleykid 对我的认可以及信任，特别感谢@valleykid 在工作中的指导及帮助，其次要感谢@华仔和@老田在工作中的默契的配合以及主动帮助，最后要感谢其他小伙伴们在工作与生活中给予援助。有你们的陪伴让感受到家的气息。 2012年是大家谈论世界末日的一年; 2012年是我开启淘宝网店创业的一年; 2012年是智能手机席卷的一年; 2012年是移动开发燎原的一年; 2012年是人生风向标指引的一年; …… 2012年对我来说是如此的重要，在特定的地方，特定的时间，遇到特定的机遇 —- 正式进入移动开发。 在金立这一年的收获： 1.鉴证了金立移动互联网的组建 2.鉴证团队的组建与完善 3.鉴证了项目迭代的各个环节 4.了解了PC端开发与移动端开发的区别 5.参与前端库组件开发 6.管理与规划 总结在金立这一年，学到的不仅仅是技术，更多的是一个公司转型的过程，一个团队成长的历程，一个项目成熟的经过以及个人人生方向的指引。","link":"/2013/10/07/2013-10-07-work-in-gionee-for-one-year/"},{"title":"移动平台前端开发总结","text":"移动平台前端开发主要是指针智能手机（iphone、android）做站点适配，并非是针对普通手机开发Wap 2.0，所以在阅读本篇文章以前，你需要对webkit内核的浏览器有一定的了解，需要对HTML5和CSS3有一定的了解。 1、移动前端开发webkit内核中的一些私有的meta标签 =&gt; 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览； =&gt; Iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览 =&gt; Iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览 =&gt; Iphone设备中的safari私有meta标签，它表示： =&gt; 告诉设备忽略将页面中的数字识别为电话号码 =&gt; 告诉设备忽略将页面中的电子邮箱 (IOS) (Android) =&gt; 说明： 这个link就是设置web app的放置主屏幕上icon文件路径。图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px） 注：红色部分为H5模板页面通用设置项。 2、如何去除IOS和Android中的输入URL的控件条 =&gt; setTimeout(scrollTo,0,0,10); 请注意，这句代码必须放在window.onload里才能够正常的工作，而且你的当前文档的内容高度必须是高于窗口的高度时，这句代码才能有效的执行。 3、如何关闭IOS中键盘自动大写 =&gt; 我们知道在iOS中，当虚拟键盘弹出时，默认情况下键盘是开启首字母大写的功能的，根据某些业务场景，可能我们需要关闭这个功能，移动版本webkit为input元素提供了autocapitalize属性，通过指定autocapitalize=”off”来关闭键盘默认首字母大写。 4、IOS中如何彻底禁止用户在新窗口打开页面 =&gt; 有时我们可能需要禁止用户在新窗口打开页面，我们可以使用a标签的target=”_self“来指定用户在新窗口打开，或者target属性保持空，但是你会发现iOS的用户在这个链接的上方长按3秒钟后，iOS会弹出一个列表按钮，用户通过这些按钮仍然可以在新窗口打开页面，这样的话，开发者指定的target属性就失效了，但是可以通过指定当前元素的-webkit-touch-callout 样式属性为none来禁止iOS弹出这些按钮。这个技巧仅适用iOS对于Android平台则无效。 5、IOS中如何禁止用户保存图片＼复制图片 =&gt; 我们可以为一个img标签指定-webkit-touch-callout 为none也会禁止设备弹出列表按钮，这样用户就无法保存＼复制你的图片了。 6、IOS中如何禁止用户选中文字(Android同样有效) =&gt; 我们通过指定文字标签的-webkit-user-select属性为none便可以禁止iOS用户选中文字。 7、学会使用webkit-box 8、如何解决android平台中页面无法自适应 =&gt; 虽然你的html和css都是完全自适应的，但有一天如果你发现你的页面在android中显示的并不是自适应的时候，首先请你确认你的head标签中是否包含以下meta标签： 如果有的话，那请你再仔细的看清楚有没有这个属性的值width=device-width，如果没有请立即加上吧！ 9、如何解决iOS 4.3版本中safari对页面中5位数字的自动识别和自动添加样式 =&gt; iOS4.3版本，升级后对safari造成了一个bug：即使你添加了如下的meta标签，safari仍然会对页面中的5位连续的数字进行自动识别，并且将其重新渲染样式，也就是说你的css对该标签是无效的。 如下改写： 12345.00元 10、如何解决Android 2.0以下平台中圆角的问题 =&gt; 考虑到border-radius的兼容性问题，使用如下方式： 定义4个圆角 border:1px solid #F8F8F8; -webkit-border-radius:5px; 定义部分圆角 border:1px solid #F8F8F8; -webkit-border-radius:5px; -webkit-border-top-left-raduis:0; -webkit-border-bottom-left-radius:0; 11、如何解决Android浏览器中webapp中圆角后存在背景色的问题（针对特定生产商的Android浏览器） =&gt; 可以通过设置父层与子层元素都具有相同圆角，并设置父层元素的背景后与底色一致。 12、如何解决移动开发中字体适配问题 =&gt; 我们推荐采用CSS3,新的长度单位REM(REM是相对长度单位。相对于根元素(即html元素)font-size计算值的倍数)。 /** 1rem=20px for 320px(中低端分辨率). * 1rem = 22.5px for 360px(高端分辨率). */ html{font-size:20px; -webkit-text-size-adjust:none;} @media all and (min-width:359px){.uc-hack{font-size:22.5px;}} @media all and (min-width:359px) and (-webkit-min-device-pixel-ratio:1.5){html{font-size:22.5px;}} （持续更新……）","link":"/2013/10/14/2013-10-14-summary-of-mobile-frontend-development/"},{"title":"蜕变·WebRebuild 2013 前端年度交流盛会邀请","text":"互联网web前端设计行业通过一段时期的茧封或焰炼，web技术使行业、企业及自身发生质的改变。痛苦的蜕变是成长的契机，在彼此互相冲击、交流、融合的对话下，将以尊重包容互助合作同步发展的心态，对行业蜕变、自我提升的过程分享自己的观点进行探讨。 2013，本届主题为“蜕变”的前端技术年度交流会已是第七届，依然如往年在深圳、广州、上海、北京、成都五地举行，腾讯ecd联合WebRebuild.ORG、深圳大学文化产业研究院、迅雷CUED主办了第七届前端年度交流会“蜕变”首站 － 深圳站，将于10月26日上午9点在深圳大学拉开帷幕。 交流会形式web前端设计主题分享、现场来宾主题交流对话探讨。 会议进行时间2013年10月26日（周六）上午 9:00 会议地点深圳市南山区深圳大学科技楼一号报告厅。 邀请参会对象互联网web前端/设计从业者及相关专业、兴趣的学生。 报名渠道WebRebuild.ORG官方网站，或添加微信公众帐号(webrebuildorg)进行相关操作。 交流会背景WebRebuild.ORG 成立于2007年，由互联网前端业界人员自发起的一个交流会组织，从深圳扩散至全国，旨在推动互联网前端web标准技术在中国的发展，致力于为同行从业者提供一个分享交流的平台，提升从业者的影响力及技术能力储备，并向发展成为推动中国互联网前端web标准技术的非盈利性组织的目标而努力。 从2007年至今，WebRebuild.ORG得到了W3C中国、Google中国、腾讯、迅雷、网易、欢聚时代、百家筝鸣古筝教育集团等企业组织、同行及会议组委志愿者的大力支持与帮助，已成为中国前端盛大的行业盛会之一。 广州、上海、北京、成都地区更多详细信息及参会报名请访问WebRebuild官方网站查阅：http://www.webrebuild.org或收听WebRebuild微信公众帐号（webrebuildorg）获取最新信息。","link":"/2013/10/17/2013-10-17-web-rebuild-party/"},{"title":"阿里前端的困局与突围(转)","text":"最近发了两条微博： 想起克军的一句话：前端研究，研究个屁~ 的确如此呀。补充下联：前端设计，设计个屁~ 前端目前最大的困境是，如 HTML 一样，无论你承不承认，市场上并不太需要 HTML 高手。 微博上的回复大部分歪楼了。上面两句话乍看有点激进，却是我的真实想法。 背后是一个问题前端的价值究竟是什么？未来应该如何发展？ 前端的价值如果你刚入行，或者从事专职前端工作未满 3 年，请忽略上面这个问题，并且尽量不要再往下看了。 我知道你会忍不住往下看，那就看吧。负能量有时也是正能量。真实面对所做的事，如实面对自己的真心，这是迟早的。有过痛，才真正懂得乐。 特别注意，下面说的前端，都是阿里的前端，其他公司切勿对号入座，每个公司的情况都不同。每个公司，前端的定位也会有差异。 阿里的前端，目前主要分两种：一种在 UX / UED 部门，另一种在技术部门，所做的事大同小异，都是负责界面交互层的开发。上游是 PD、交互、视觉等，下游是后端开发人员、测试等。技能主要是 HTML、CSS、JavaScript，有些前端团队比如支付宝还直接负责 Velocity 等模板层的开发。这是阿里目前前端的现状。 前端是后端数据的第一消费者，也是最贴近用户的程序员。 一切看起来很美。 前端的价值在哪呢？很多人会回答： 实现界面交互。 提升用户体验。 第一点是前端的本职工作，也是前端岗位存在的原因。第二点也不多说，前端做得好，对用户体验是有益的。 让人纠结的，是前端有价值，可是，这价值真的很重要吗？真的值得做为一个职业投入一辈子吗？做技术的，可能都会有类似纠结。但传统技术，纠结相对少点。比如搞数据库的，有一堆牛人榜样，搞网络、安全等等的，也是如此。这个现实的背后，是因为： 这批传统技术的背后，无论是数据库底层优化，还是网络优化、安全防范等等，做得好，对业务都能直接产生影响，比如大幅度降低硬件成本等等。 价值是直接的，可见的，不太会被质疑。 然而前端的价值，没有人会直接否认，但看得明白的，都知道： 淘宝的核心用户体验，并非是 UI 层面带来的，而是 C2C 的模式，是同等品质下商品的价格，还有支付宝的便捷等等。前端的确很重要，但真的，也就那么着。比如京东，很多交互细节做得其实不咋的，但京东靠着靠谱的物流、货到付款等方式提升了整体购物体验。对阿里来说，用户体验非常非常重要，但前端在用户体验层面能做的其实很少很少。 一个事实把国内大部分公司的 UX 部门解散掉，也不会太影响产品的体验。在国内，UX 主要还是起到美工的作用，虽然我不想承认。 前端依旧是美工，而且仅仅是实现工。 在阿里，我们不得不承认一个事实：前端的确有价值，但放在全局来看，前端产生的价值并非核心价值。 在阿里，虽然前端的工作已经不可或缺，但对大公司而言，不可或缺的岗位多了去呢，不可或缺不代表有核心价值，我就不说了。 前端的未来发展前端，往后是技术，往前是体验。我的理解，前端的未来发展，有两个方向： 前后端体系的融合，技术平台化。 范例是 Google、Facebook 等公司的技术体系，不细分前后端，都是 Web Developer，在整套技术平台上，Developer 都可以从后到前高效开发。技术平台本身由 Engineer 维护，有各个领域的高手，包括前端的。 前端技术带来的体验革新，成为某些产品的核心竞争力。 典型的比如 Path，国外有很多创新型项目，体验是核心竞争力之一。在这类产品中， 前端带来的用户体验很关键。 然而，上面两个方向，在阿里的现状下，困难重重： 技术平台化之路很难。 阿里现有的技术体系，前端只是薄薄的一层，要靠这薄薄的一层，来渗透甚至改革现有前后端开发模式，非常困难。支付宝算是走在前面，已经摸索了一年多，但越来越觉得，前端的绝大部分问题，其实都需要后端才能解决。去跨团队推动也可以，因为难，所以前行也挺有挑战挺有意义。可是，更悲催的事实是，技术平台化，前后端开发模式的融合，目前来看，并不是阿里的痛点，还没有到这一步，没这个强烈需求。需求不强烈，意味着缺了“天时”。很希望我的想法是错的。前后端的技术平台化之路，还有一个很现实的问题是，马云留下的隐患：平凡的人去做非凡的事。虽然现在有意不提这句话了。这句话很伤人，特别是技术人员，然而事实就是事实。即便技术平台能建成，在平台之上，阿里现有的开发人员，无论是前端还是后端，很多人可能还欠缺了不少能力。Facebook、Google 等玩起来，有个重要因素是精英文化。这话题不多说。现实的残酷，虽然也有方法是改变。 体验创新之路也非常难。 在淘系可能相对好点，在支付宝，前几年首要的问题是安全、稳定，接下来几年之内，依旧是安全、稳定。创新受产品形态的影响非常大，没有一个好的产品，妄谈创新。可以有不少微创新，可以有很多小而美，但目前都触不到痛点，隔靴搔痒。真正承担阿里用户体验的，是 CDN 团队、是数据库团队、是 PD、是运营、是大安全…… 继续希望我是错的。 以上两个方向，虽然困难重重，但在一些新领域，却充满机会与希望： 无线领域。 未来是属于无线的，这话说到心坎上。目前阿里的无线才起步，起步意味着百废待兴。无论是前后端的技术体系，还是产品的体验创新，在无线领域，前端的机遇与挑战都很多。并且其价值，有可能变成核心价值。这一点，希望我的判断是对的。（编者注：在阿里“移动”叫“无线”） Node.js 领域。严格来说是 JavaScript 程序员的新舞台。通过 Node，前端程序员可以摇身一变，变成传统程序员。数据库、网络、业务架构等等技术核心领域，都可以通过 JavaScript 来达成。Node 社区是迷人的。同样，希望我的判断是对的。 上面的分类有点混乱，下面继续乱谈： 创业。 在很多产品中，前端虽然很难产生核心价值，但在有竞争的地方，附属价值经常会成为核心竞争力。比如出去创业，如何在大量同类产品中脱颖而出，前端界面层的实现非常关键。可是，无论是淘宝，还是支付宝等，目前都已经过了初期创业期。有时真希望，易趣如果还强大着该有多好。 转行。 的确，没必要因为懂 JavaScript，就一辈子做前端。没必要限定自己的发展，可以做 2-3 年前端，然后再去做 2-3 年开发，还年轻的话，可以继续尝试各种岗位，说不定，10年后，就变 CTO 了。 从人的一生来看，前端只是一段很小的旅途。它能带给你我们的已经不少，舍弃惯性，脱离舒适区，长远来看才能走得更远。放弃有时也是坚持，重要的是你心中的梦是什么。 感悟与坚持纯技术上，前端目前的很多发展，只是在满足业务，并没有真正对业务带来“从无到有、促进变革”的变化。从公司的角度讲，并不需要那么多前端牛人。这是我那条说 HTML 高手是屠龙术的微博的含义。 另一个角度上，前端技术这些年的变化，无论是 YUI 的发展、还是最近两三年兴起来的模块化开发理念、以及 Node.js 带来的前端工具变革、还有 Backbone 等类库背后的 MVX 的发展，这些都切实推动着前端往前发展，虽然很慢很慢，虽然短时间内很难直接影响业务价值，但我相信，这类工作的价值，也很大。 一类是直接促进业务发展，一类是缓慢带动人员的成长。这两类工作，都非常有价值。一个着力于现在，一个发力于未来。 看起来，路都很清楚。然而我们都是人不是神。最后以一段人与人之间的对话来结束这篇充满负能量的文章： 章小新：有一个现实是，如果在这块上长时间的价值不被认可，那很有可能真正产出的价值没有我们想想象的大，是否是我们自己深限其中？ 有时虽然不想往这方面想，但又是不得不仔细深思的问题。 玉伯：毕竟我们都是人，要坦诚面对自己的真心，包括贪欲。比如一个事，如果做了 5 年，依旧得不到直接认可，也没更多物质上奖励，我估计你也很难做下去了，或者就是打着酱油，干着其他有意思的事情去了。 章小新：哈，今天的话题的确是沉了点，今天上午还和同事们讨论过~~~ 先认清自己，再从容微笑去面对。 玉伯：从容微笑谈何容易。从容微笑的一个前提是，认清了自己，找到了今后要走的方向，知道接下来该怎么走下去。 李牧：这么说好像我有多么淡定一样。。其实没有了。会很计较，但是现实面前了。 玉伯：从容不是有希望，也不是在路上，而是自己喜欢自己做的事情。又变鸡汤了，不过发现很多鸡汤越来越有道理，得真心去信。真正的认可是自己给自己的。 柏林：我不是做前端的，一直在关注大家。 呵呵。看到这句话蛮有感触，要体验过鸡汤的过程，才能品味到真实的味道。（说得不好哈） （完）文 / 玉伯 PS：把这篇文章发出来，很犹豫。把这些想清楚的事情说出来，虽然可能会影响团队士气，会打击工作不久的前端，但隐瞒更不可取。 前端还很年轻，如何发展，如何前行，需要所有前端们一起来思考。我们需要未来，也需要真实。我们不需要的是混日子。我们往哪里去，取决于我们自己。 原文地址：http://www.chengxuyuans.com/program_life/67632.html","link":"/2013/10/23/2013-10-23-thinking-about-frontend-future/"},{"title":"移动开发总结（转）","text":"1、低版本Android下input有CSS3动画会让输入框失去焦点，解决办法是低版本Android下去掉所有CSS3动画。 1234567891011121314.ua-ios .ipt{ -webkit-transition:all .5s;-moz-transition:all .5s; -o-transition:all .5s; -ms-transition:all .5s; transition:all .5s;}.ua-oldAndroid .ipt { -webkit-transition:none; -moz-transition:none; -o-transition:none; -ms-transition:none; transition:none;} 2、-webkit-user-modify: read-write-plaintext-only;作用是去掉输入框聚焦时候的白色背景 ； 但是这里有一个问题，Android4.0以上的系统，当软键盘激活出来的时候read-write-plaintext-only的输入框不会居中在屏幕中间，这里需要根据实际情况进行取舍。 3、translate3d可以让IOS启用硬件渲染，动画效果会更加流畅，基本上能解决所有抖动；但在Android下带来新的问题——只要页面里面有节点拥有transform属性，输入框都会不正常（聚焦不正常、输入时上下抖动等），此外还会导致节点渲染变慢（如点击出下啦菜单渲染缓慢）。 再次强调CSS3的动画、投影在Android下尽量避免。 123456.ua-ios .mail-list .list-item, .ua-ios .menu-item, .ua-ios .menu-split { -webkit-transform: translate3d(0,0,0); transform: translate3d(0,0,0); } 4、Android 2.3.7 下不加透明border，会导致溢出隐藏失效。 123456.atts .att-preview { overflow:hidden; width:50px; height:50px; border:1px solid transparent;} 5、IOS下fixed定位（比如框架顶部提示信息），当键盘收起的时候会有残影：fixed元素不会随着键盘收起而移动到页面顶部，而是保持在页面中间，需要hack改成绝对定位。 12345678910.frame-tips { position:fixed; z-index:30; left:0; top:0;} .ua-ios .frame-tips { position: absolute;} 6、在iPad1等低版ios下，opacity和其他属性一起改变，会导致transition中重复执行三次，所以要么只改变opacity实现淡入淡出，要么只改变非opacity属性。 123456789.mRead-reply .btn { position:absolute; right:0; top:0; /opacity:0;/ overflow:hidden; display:block; width:64px;} 7、在Android4.1下，如果textarea聚焦的时候，其高度或者其兄弟节点的高度产生变化，那么textarea就会被软键盘挡住而不会自动调整位置，这里需要去掉所有效果，默认显示输入框展开状态。所以Android下尽量不要在textarea和input上做动画。 8、Android下div的高度设置成100%，同时设置其overflow:auto;那么滚动条就会出现在这个div上面。 这个时候会出现抖动，所以建议Android下页面的滚动能且只能出现在body节点上面！ 原文章地址：http://ntesmailfetc.blog.163.com/blog/static/20628706120139184457401/","link":"/2013/11/20/2013-11-20-html5-and-css3-for-mobile-development/"},{"title":"2013年终总结","text":"2013年就要过去了，像往年一样总结一下过去的一年我的变化。 生活2013年，我的本命年，生活和感情在我的人生中也开了一个小玩笑，让我心情低落过、脾气暴躁过、在游戏中颓废过，但我的认知从未游离过，我了解我自己，不快乐的都已经过去了，重新认识自己，做好自己，为了明天，为了自己。 美好的瞬间，从现在开始， Let’s go! 在深圳第一次陪我家的“执子闲人”过了三个生日，送去了一份生日礼物 —— ipad 4 在深圳第一次和“执子闲人”去东部华侨城——二日游，也许去的人太多，没有想像中的那么好玩，但华侨城的景色和设计的确不错。 在深圳第一次和“执子闲人”订了一个KTV，傻傻的吃喝玩唱3小时。 在深圳第一次和“执子闲人”一起陪着侄女和外甥女简单的了解深圳。 今年夏天再次去清远二日游（ZTE 第一次、Gionee 移动互联网 第二次、Gionee 移动互联网战略第三次），但是和以往的心情却不一样，“清远鸡”味道着实不错，但我再也不打算去了，如果你下次去，记得帮忙带两只咯。 仔细想想今年去的地方也是挺多的，拿着单反、骑着山地车、望着大海，大声说“Hong Kong am here”! 工作年初的规划，一个一个的顺利完成。（深入了解了组内JS框架的架构和设计原理以及使用场景等，率先在组内切换工作环境到 Linux，创建了基于 Compass 的 LookitUI（基于前端的UI库），深入的了解并使用 backbone 进行开发。） 在产品线成功的担任XX项目 Master，离自己的职业规划又迈近了一小步！ 今年我做了大小十几次的演讲，参加了每一期的头脑风暴以及技术分享会。其实演讲也是一种需要大量练习才能买得的技能，我现在也只是做到了最基础：弄清楚目标听众是什么，吸引他们的注意，表达我的想法。最近也有去看了很多大牛的演讲和分享，我自愧太不如了，以后还得多加练习，积极主动。 今年我成功的创建了Nodejs交流群（QQ群号：322794303），欢迎你的加入。成功的用Nodejs开发打包工具、CMS后台、年会抽奖系统。 技术学习方面，粗而广的学了一些东西， Nodejs、MongoDB、Linux、Android、BackboneJs、SeaJs、AngularJs、响应式流程等。我学技术的原则是熟练度可以不高，但原理和模式一定要理解。 读书方面，粗略的看了这几本书， Nodejs 、MongoDB、JavascriptMVC、淘宝技术这十年等，但对技术文章的阅读上有了很大的提高，同时对提高自身修养方面的关注度也近一步提高了。 最后的最后，跟我们家的“执子闲人”恋爱四年了，回想过去我们也遇到过很多的艰难，最终都挺过来了，感谢在我最困惑的时候，有你的陪伴。我相信，以后无论发生什么，我们都能一路走下去。","link":"/2013/12/28/2013-12-28-2013-year/"},{"title":"金立移动互联网第三产品中心年度盛会","text":"从移动互联网运营部到移动互联网第三产品中心的转变，标志着我们目前各产品线的良性成长。从个位数迅速发展到百位数、从第一个迭代版本到第几十个的迭代版本、从单一结构发展到 多元化结构、从年会时３桌的人数迅速发展到上10桌的人数、奖项从单一到多元化和人性化的分布。2013年是成长的一年，也是快乐的一年，因为和你们在一起。 2014 year department party, Ｗe are here in the sand beach party，where are you ? sand beach party 现场盛会 我们的掌柜 金立移动互联网运营部各位大佬们 青春活力的萌妹纸 卡哇伊的妹纸 艺样的演技，人气之王 各种舞蹈，各种帅锅美女 有了弓箭10,再也不用担心打羽毛球啦 非诚勿扰，这在等你 法海大闹许仙 比翼双飞，让我们飞的很高 海边盛会，火爆的现场，平静的夜晚，美妙的海上日出，享受生活，享受每好的时刻。 2013年过去了，2014我们要更加的努力！","link":"/2014/01/18/2014-01-18-third-product-center-annual-party/"},{"title":"从 wordpress 搬迁到 github pages","text":"一直在寻求快速发表文章的工具，于是不停的在尝试。期间尝试过win7和Ubuntu下各种Ｍarkdown 编辑预览工具， 甚至使用开发工具ST2(Sublime text 2)装 Ｍarkdown 插件来更新博客，各种尝试，各种折腾。也许是因为之前对动态站点的理解， 导致思想上一直认为 —— WordPress 或者 emlog 等是最好的博客系统没有之一的原故。 自从使用nico生成了ICAT文档后， 有一种冲动想立刻在上面建立起我的博客副本，感觉挺不错的。 昨天打算在 Ｗordpress 的编辑器里写了一篇年会抽奖系统(nodejs+mongodb)的文章，由于涉及到很多的代码片段，有的需要格式化，有的只是要使用code标签。 当我在编辑模式和HTML源码编辑模式下各种抓狂之后，决定放弃 ＷordPress，使用 github。这样我就可以在我喜欢的编辑器里，使用我熟悉的markdown语法来写博客。 迁移的步骤如下： 先阅读阮一峰的一篇很赞的文章搭建一个免费的，无限流量的Blog—-github Pages和Jekyll入门 备份 wordpress 数据库，并转换日志为.md文件 下载一份 jekyll 模板 (这里感谢展新的模块kunka) 将第二步中的所有.md文件放到_posts文件夹中（手动处理好.md文件中非法的字符和标签） 模块 kunka 中支持两种评论插件（disqus 和多说），进行简单配置即可直接使用。 将本地文件提交到github 迁移的注意点如下： github pages 分为两大类，一类是以根站点（github user or organization site, e.g. username.github.io), 另一类是项目站点（project site, e.g. username.github.io/projectname),请参考官方文档 域名域名(顶级域名绑定——只需要把顶级域名的Ａ记录指向到204.232.175.78， 非顶级域名绑定——只需要把非顶级域名绑定的cname的DNS解析指向到username.github.com（请将username换成你的用户名）)，查看官方文档 关于 jekyll 的相关操作，可以查看官方文档 对以上有任何的疑问都可以联系我或者给我留言，谢谢！ 最后，整个博客都是开源，博客中的样式、模板都可以直接使用，但文章内容和图片内容保留版权，未经允许禁止使用！","link":"/2014/01/22/2014-01-22-wordpress-blog-to-github-pages/"},{"title":"2014年新金立新征程","text":"新金立、新征程，2014年金立集团新年联欢晚会，金立人齐聚一起。新金立、新征程！ 今年的年会如以往不同，处处都透露出公司的改革和创新，从高层的新动态，从制度的规范健全，从对研发的大力投入，每一个细节，每一个创新，每一次进步，都直接映射出金立战略， 创新的金立、国际的金立、跨界的金立。 让我们一起来看看，新金立，新征程，不一样的视界，不一样的理念！ 2014年金立集团新年联欢晚会,新金立、新征程 高层领导新形象 高层领导新形象（刘董） 高层领导新形象（卢总） 参加晚集团年会回来都晚上12点多了，但本次年会却收获大大的，高层的行为举止、积极的心态、不一样的形象， 简单的一句话来概括现场所有的感受和本次收获的真谛——心有所归、力归所用，眼观所属，认清自我，让心态决定选择，让选择决定人生！","link":"/2014/01/26/2014-01-26-gionee-group-annual-party/"},{"title":"Jekyll中使用google-code-prettify语法高亮","text":"之前使用wordpress时，一直都是用的 SyntaxHIghlighter 代码高亮的工具，虽然SyntaxHIghlighter 的代码高亮显示的很漂亮，无奈加载太慢，且对markdown写的文章支持的还不是很好，只能舍弃了。现在用的这个是google-code-prettfy，效果也相当不错。最重要的是，非常小，加载速度比SyntaxHighlighter快得多，而且，可以直接使用markdown的语法去写代码。 准备工作Google Code Prettify下载主题库第一步：引用prettify.css和prettify.js将下载后的Prettify压缩文件解压到指定文件文件夹,将prettify.css和prettify.js文件放到项目文件夹下（例如：assets/theme/prettify目录）,然后打开需要引用的页面，添加如下代码： &lt;link href=&quot;/assets/themes/prettify/prettify.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;all&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/assets/themes/prettify/prettify.js&quot;&gt;&lt;/script&gt; 考虑到加载速度，最好将js写到文档末尾，body闭合标签之前，css写到头部 第二步：高亮代码块添加以下代码，用于识别并高亮代码块 1234567&lt;script type=&quot;text/javascript&quot;&gt; // 需要引入jQuery $(document).ready(function() { $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto'); prettyPrint(); });&lt;/script&gt; 第三步：显示全部行号默认prettify只显示行号5,10,15…,可以给pre标签下的li设置以下样式 pre li{ list-style-type: decimal; }第四步：选择喜欢的主题样式打开主题库选择喜欢的主题，并复制或者下载主题样式文件，替换默认主题样式文件（prettify.css）,本文使用的主题是Desert 第五步：完成到此Google Code Prettify已可以正常使用了，现在可以直接用markdown的前置4空格来写代码了。 另外，如果博客中的代码块存在滚动条可以通过如下代码实现自动换行 white-space:pre;white-space:pre-wrap;word-break:break-all;word-wrap:break-word;如在操作过程中存在任何问题，请给我留言，谢谢！","link":"/2014/02/19/2014-02-19-jekyll-use-google-code-prettify/"},{"title":"代码发布流程研讨会","text":"代码发布流程研讨会 Created by hxrealm 目前项目上线流程 项目上线流程（上） 开发完成、测试完成 前端打包静态文件包 后端打包后台文件包（同时修改后台版本号） 后台开发汇总前后端文件包 邮件运维及相关人员 项目上线流程（下） 运维整理后，开始更新 先更新静态文件包 再更新后台文件包 最后更新前台文件包 中间任一流程出问题，重新更新 如更新问题来源于程序，则回滚 IT大佬的发布流程？ 各大IT公司的发布流程 电商大佬（阿里、淘宝） 传统通信（中兴、华为） IT互联网（百度、腾讯、网易） 中小企业、小团队 发布流程是否可以这样？ 静态文件发布流程（上） 开发完成（自测）、测试人员完成 后台上传更新的静态文件 后台更新版本号 打开浏览器查看是否正常 静态文件发布流程（下） 更新失败（立刻修改回原版本号） 否则更新上传原版本文件 打开浏览器查看是否正常 你有什么好的建议？ Thank You!","link":"/2014/03/01/2014-03-01-publish-code-to-online/"},{"title":"新环境新动力","text":"今天部门即将开拔至阳光高尔夫大厦，虽然对东海国际(五星级写字楼)有点不舍，但是看着部门的成长，集体的壮大，需重新调整办公区域。离开了东海走向阳光， 我相信在新的环境下我们可以更好的成长。 下面同我一起参观新环境下的新元素： 根据业务线进行区域划分（BI支付、电商购物、游戏大厅、浏览器导航） 根据业务线进行区域装扮 （非主流的元素、温馨的家园、时尚的风格） 健身活动室（跑步机、桌面足球、动感单车、体感运动等等） 特色会议室（白宫、白金汉宫、克里姆林宫等等） 特色的办公墙面（可以绘画、可以记录） 新环境新动力，让我们一起成长。","link":"/2014/05/30/2014-05-30-new-power-new-life/"},{"title":"《卓越经理人的七个习惯》培训有感","text":"最近公司组织了一次《卓越经理人的七个习惯》的培训，旨在提升管理层的管理水平，我很荣幸参与了这次课程的培训， 本次课程让我收获了很多，学习了很多，下面就谈谈这次培训的一些感悟吧！ 这次课程的内容主要是基于史蒂芬·柯维（Stephen R. Covey）的《高效能人士的七个习惯》并结合讲师独特的讲解手法， 通过案例、场景、现在模拟等方式，透彻的分析如何做好个人管理、建议人际关系、自我的持续提升。 卓越经理人的七个习惯的自然法则和观念转移分别： 自然法则人的反应不是受环境的制约，人有能力也有责任通过自主意识选择自己的反应。 观念转移我们不要去总是去抱怨环境的不利、条件的限制和他人的缺失”，而应该考虑“在现有条件下我能做什么”。 自然法则任何事物的创造需要经历两个过程，先想出来，再做出来。 观念转移工作不能想做什么就做什么，做到哪里算哪里。 工作的第一步如何开展，过程中如何选择，都要根据最终的目标来进行。 自然法则重要的少数往往决定结果的多数。 观念转移我们在做事件时要以重要为依据而非紧急性。这样才能事半功倍。 自然法则唯有双方都能获利，这样的关系才会长久。 观念转移从我赢你输的小圈子里跳出来，用利人利已作为出发点来考虑人际问题。 自然法则先诊断，再开药方。 观念转移先理解别人再表达自己，为理解而去倾听，而不是为了反应而倾听。 自然法则整体可以大于个体的总和。 观念转移珍惜差异，善于从不同意见中吸取好的主意。 自然法则产出和产能要平衡。 观念转移我们需要自我更新，从而使自己走更远的路。磨刀不误砍柴功。 通过这次培训，让我更深层次的了解“原则”的定义，并在如何应对生活层面、工作层面等复杂的环境方面得到提升， 同时学习到了思维模式的转变、四象限法则的运用、人际交往的整合等等。 管理是一门艺术，需要主动积极、用心体会、用行动去描绘。 最后给大家推荐两本书： 《小强升职记》 – 邹鑫 《浪潮之巅》 – 吴军","link":"/2014/07/20/2014-07-20-the-7-habits-of-outstanding-manager/"},{"title":"2014年终总结","text":"2014年过去了，有些计划还没开始就已经结束，这一年失去了许多，但也收获了不少，2015年来了，值得回顾与总结一番。 还记得2013年底时，被口头上任命为项目经理（项目master），开始协助管理项目组内外的各项工作。转眼间一年过去了，在这一年里经历了产品、设计、研发、测试、运营、商务等各环节沟通交流与协助，也有多次参与了公司培训、内部交流、外部学习与交流等的机会，从多方面提升了个人综合能力，我想这应该就是今年最好的收获，在此感谢公司、感谢领导、感谢每位不伙伴，特别感谢@sam、@大大、@valleykid 和研发小组的每位同学的支持。 今年写的博客并不多，平均一个月一篇都不到，字应该到码到工作汇报和总结上去了。技术方面主要还是宽度的拓展，看的多动的少，期间虽然也看了些书籍《Backbone.js开发秘笈》、《Node.js开发实战详解》、《Javascript 框架设计》、《HTML5 Canvas开发详解》、《Object-C 基本教程》等，但没有深入研究和大量在项目中使用。 今年比较痛心的是—奶奶去世了！在所有家里人都回去的那段时间里，我感受体会到了亲情的可贵、友情的重要、现实与理想的差距。我想以后要正面对人生，做好自己，让生活更精彩。 五、新年计划2014年是在“无状态”下度过的，虽然经历了很多，但没有提炼、没有总结、没有按着规划的方向前进。好在今年有太多的事情让我感悟到，适合地做些规划和总结，多了一些动力。年底总结也就多了些评判。 简单地列举如下： 管理水平的提升：时间管理和项目管理 技术水平的提升：宽度和深度 开发一套UI组件，制定相关规范，提升团队效率 学车考驾照 建房子 拍婚纱照和订婚（收获与娟儿五年的恋爱） 至少和女朋友一次国内长途旅游，一次出国旅游 加强对家人的陪伴和对朋友的维护","link":"/2015/01/10/2015-01-10-2014-year/"},{"title":"快速提升前端开发工作效率的总结","text":"近期在考虑团队建设以及前端小组的效率提升，故对前端开发过程中效率的提升做了个简单的总结，同时也希望对前端新人有点帮助。 选择一个好的编辑器，并熟练使用她（他）一个好的编辑器，至少应该具备： 语法高亮 括号匹配 能快速定位 快速打开文件 在文件中查找 在文件夹中查找 跳至某一行 能安装插件 推荐编辑器： SublimeText Hbuilder Intellij IDEA 能熟练使用一个前端调试工具一个好的前端调试工具，应该具备： 网络请求数据查看 审查元素 打断点和断点调试 控制台打印log PC端推荐调试工具： 谷歌浏览器（chrome） 火狐游览器（firefox） 苹果浏览器（safari） 移动端推荐调试工具： 谷歌浏览器（chrome） 苹果浏览器（safari） weinre UC浏览器 良好的前端开发辅助环境前端模板、初始化项目、组件依赖管理、工具集等 Yeoman 项目脚手架 Bower 依赖管理 Grunt 前端构件工具 node 前端工具开发和运行环境 less css预编译 文档规范一个快速发展中的技术小组，应该具备： 需求文档（PM） 视觉规范（设计） 接口文档（开发） 代码规范（风格与全名等） 其他当然还可以通过其他方式以及相关的组合来提升效率，例如： svn、git、ruby、compass、yuicompress、coffeescript、代码片段、模板页面、bootstrap、前端常用插件 最后的最后，欢迎大家来补充~","link":"/2015/02/27/2015-02-27-how-to-improve-the-efficiency-of-fe-develop/"},{"title":"Linux命令行和Shell高效率使用方法(转)","text":"快速调用history中的命令 Ctrl+R快速搜索history Ctrl+P显示上一条命令 快速执行一条history命令：!!/!-number 快速进入某些目录 键入cd～可直接进入用户的home目录； 键入cd－可进入上一个目录。 export CDPATH=.:~:/etc:/usr/local mkdir -p ///***/ alias cd3=”cd ../../../“ 一次运行多个命令 在一个命令行中还可以置入多个命令，用分号将各个命令隔开 $last;exit $make &amp;&amp; make install 命令行下快捷键 Ctrl+a：把光标移到行首。 Ctrl+e：把光标移到行尾。 Ctrl+l：清除终端。该快捷操作与在命令行键入clear作用相同。 Ctrl+d：从Shell提示中注销并关闭，使用该快捷键就不必键入exit Ctrl+u：删除光标至行首的所有字符,使用这一快捷操作可以清除从光标处到行首的字符 Ctrl+K：删除从光标到行末所有字符。 Ctrl+t：新建屏幕。 Alt+1到9：选择屏幕。 Ctrl + F :向前移动一个字符。 Ctrl + B :向后移动一个字符 Alt + F : 向前移动一个单词。 Alt + B : 向后移动一个单词。 在文件里查找grep -rlI '\\&lt;main' . find -type f -name *.java -exec grep -l '\\&lt;main' {} \\; 快速的建立一个文件cat &gt;&gt; filename ，输入一些内容然后按Ctrl-d结束输入。 将文本文件中DOS换行符号转化为UNIX的换行符号tr -s &quot;\\r&quot; &quot;\\n&quot; &lt;inputfile tr -s &quot;\\r&quot; &quot;\\n&quot; &lt;inputfile &gt;outputfile 当然你使用vim编辑文件时，vim也提供文件转换功能// 整个文件大小写转换 tr a-z A-Z &lt; **.txt tr A-Z a-z &lt; **.txt Shell 脚本 $0为程序名称，$1为第一个参数，$2为第二个参数，依次类推，直到$9为第九个参数。 特殊变量$#测试执行脚本时包含的命令行参数个数。 变量$*将命令行中提供的所有参数作为一个单词处理，它将多个参数看成 一个参数。 变量$@将命令行中提供的所有参数作为同一个字符串中的多个单词处理。 shift命令能够改变命令行参数的相对位置。默 认将每个参数变量左移一个位置 使用-t指定一个计时器，计时数满还未输入，read返回一个非0的退出状态。 使用-n指定输入的字符个数，输入达到预定数目时，就自动结束输入 使用-s使输入不显示在终端（例如输入密码） shell 调试 set -xv dstat &amp; sar iostat, vmstat, ifstat 三合一的工具，用来查看系统性能。 官方网站：http://dag.wieers.com/rpm/packages/dstat/ 你可以这样使用： alias dstat=’dstat -cdlmnpsy’ vim 命令 查找一个字符：fx 重复上次find: ; 重复执行上次：. w 下一个单词开始字符 e 下一个单词结束字符 b 上一个单词开始字符 H M L 目前屏幕的第一行,中间行，最后一行 gg G 文件的第一行和最后一行 拷贝到指定寄存器：yt{标识符} Ctrl + r{register}调出寄存器的值 分割窗口：split vsplit 超级自动补全：ctrl-N 转到一个变量定义的位置: gd(文件) gD(全局) 快速查询命令 :K 2K 匹配花括号：% 选取标志符的内容：va{ vit vi{ 修改标示符的内容：ci{标识符} 删除标志符的内容：di” 删除指定行前的内容：:10,20g/^$/d 原文来自：http://www.cnblogs.com/thinksasa/p/3507714.html","link":"/2015/02/27/2015-02-27-quick-start-guide-of-shell-command/"},{"title":"决择","text":"还记得在14年总结的时候提到过今年的规划，今天终于做下了这个决择，无论是否对错。 一直以来我总是徘徊在技术与管理之间，但是我觉得这里的“度”我把握的不是很好。最近在和朋友交流中，其实发现自己现在遇到了一些瓶颈，在管理方面，经验不是很丰富，在技术方面，虽然有一定的宽度，但是深度自己还是比较清楚的。因此今天我调整了一下个人的方向，具体如下： 关注管理动态，多看书，多学习，弱化管理权限 找准技术方向，深入了解与研究 建立良好的人脉圈，走出自我 提高自我修养和素养","link":"/2015/03/03/2015-03-03-happy-day-for-free-heart/"},{"title":"MAC OS X 10.10.1下安装php扩展","text":"年后开发环境从ubuntu 14.0.4迁移到MAC OS X 10.10.1 Yosemite版本，本以为ubuntu中编译过的php扩展可以直接拷贝使用，其实是我“想多了”。除了常见的*unix系统的基本操作相同外，还是存在很大的差异。现记录一下mac os下如何安装php扩展，以便后面查阅。 安装PHP扩展要求你的Mac系统已经安装了Xcode环境和命令行开发工具，如果还没安装，请先使用Shell安装。 xcode-select --install 为了扩展管理方便，首先来安装pecl扩展管理器。 cd /usr/lib/php sudo php install-pear-nozlib.phar 安装Redis、Memcache、Mongo等扩展。 sudo pecl install redis sudo pecl install memcache sudo pecl install mongo 将扩展配置添加的php.ini文件中： [memcache] extension=memcache.so [mongo] extension=mongo.so [redis] extension=redis.so 由于Mac自带的PHP环境是不包括mcrypt扩展的，所以需要下载同版本的php源码包，单独编译这个模块加载。从官网的归档里面找到php5.5.14的源码包，下载：http://php.net/releases/ tar zxvf php-5.5.14.tar.gz cd php-5.5.14/ext/mcrypt/ phpize ./configure make sudo make install 配置Mcrypt extension=mcrypt.so 为了加速，还需要打开opcache。 zend_extension=opcache.so [opcache] ; Determines if Zend OPCache is enabled opcache.enable=0 ; Determines if Zend OPCache is enabled for the CLI version of PHP opcache.enable_cli=0 如果在安装过程中PHP动态编译出现Cannot find autoconf错误： Configuring for: PHP Api Version: 20041225 Zend Module Api No: 20060613 Zend Extension Api No: 220060519 Cannot find autoconf. Please check your autoconf installation and the $PHP_AUTOCONF environment variable. Then, rerun this script. 请安装autoconf brew install autoconfig","link":"/2015/03/09/2015-03-09-mac-os-x-install-php-extension/"},{"title":"移动端浏览器的私有Meta属性的整理","text":"最近与浏览器客户端开发同学在探讨关于浏览器通用Web API实现方式，例如：横竖屏切换、日/夜间模式、全屏模式、页面模式等。通过讨论并与欧朋（Opera）、QQ、UC等浏览器团队进行相关交流，得到的结论————无内核开发的版本，很难彻底解决渲染、网络操作、安全等所带来的问题，但也是可以通过应用层的某些技巧方式满足部分的需求。 今天主要是整理一下移动端浏览器的私有Meta属性的使用场景以及相关注释，以便查阅： 强制让文档的宽度与设备的宽度保持1:1，并且文档最大的宽度比例是1.0，且不允许用户点击屏幕放大浏览 1&lt;meta content=”width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0;” name=”viewport” /&gt; iphone设备中的safari私有meta标签，它表示：允许全屏模式浏览 1&lt;meta content=”yes” name=”apple-mobile-web-app-capable” /&gt; iphone的私有标签，它指定的iphone中safari顶端的状态条的样式 1&lt;meta content=”black” name=”apple-mobile-web-app-status-bar-style” /&gt; 告诉设备忽略将页面中的数字识别为电话号码 1&lt;meta content=”telephone=no” name=”format-detection” /&gt; UC浏览器和QQ浏览器私有Meta属性目前国内浏览器内核开发团队主要有欧朋浏览器（oupeng）、UC浏览器、QQ浏览器，其中欧朋浏览器（oupeng）采用Presto内核（Opera 7）以及webkit内核（Opera 10），UC浏览器与QQ浏览器分别采用U3内核（Webkit内核）和X5内核（webkit内核），这里我们主要是介绍一下基于webkit内核定义的私有属性有哪些。 UC浏览器设置屏幕方向为横屏还是竖屏 1&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait|landscape&quot;&gt; 设置是否全屏，yes表示强制浏览器全屏 1&lt;meta name=&quot;full-screen&quot; content=&quot;yes&quot;&gt; 缩放不出滚动条 1&lt;meta name=&quot;viewport&quot; content=&quot;uc-fitscreen=no|yes&quot;/&gt; 设置no后用户缩放与标准浏览器缩放一直，设置为yes后，用户缩放金放到图片和文字，不出现横向滚动条。 排版 1&lt;meta name=&quot;layoutmode&quot; content=&quot;fitscreen|standard&quot; /&gt; fitscreen 模式简化页面处理，适合页面阅读节省流量，standard模式和标准浏览器一致；一旦设置 layoutmode meta 后，用户使用浏览器提供的的排版模式选项将会无效。 夜间模式 1&lt;meta name=&quot;nightmode&quot; content=&quot;enable|disable&quot;/&gt; nightmode 的值设置为 disable 后，即使用户使用浏览器的夜间模式，页面的表现也仍然是非夜间模式。 强制图片显示 1&lt;meta name=&quot;imagemode&quot; content=&quot;force&quot;/&gt; UC浏览器为了节省流量，为用户提供了无图模式，但是如果页面的图片是必不可少的，如验证码的，需要强制浏览器显示图片，可以设置 imagemode， 不影响子页面。通过META设置图片加载方式会作用于整个页面，如果希望对单个图片进行设置，那么可以使用这个 1&lt;img src=&quot;...&quot; show=&quot;force&quot;&gt; 应用模式 1&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;/&gt; 使用了application这种应用模式后，页面讲默认全屏，禁止长按菜单，禁止收拾，标准排版，以及强制图片显示。 QQ浏览器设置屏幕方向 1&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait|landscape&quot; /&gt; 设置全屏 1&lt;meta name=&quot;x5-fullscreen&quot; content=&quot;auto|true&quot; /&gt; 设置屏幕模式 1&lt;meta name=&quot;x5-page-mode&quot; content=&quot;default|app&quot; /&gt; APP 网页应用模式（定制工具栏，全屏显示）","link":"/2015/05/03/2015-05-03-mobile-brower-web-page-meta/"},{"title":"Javascript实现两个超大数字的相加","text":"两个超大数字相加的实现 分析：由于数字类型长度限制，故两个超大数字应为字符串类型。因此两个超大数字相加实则为两个字符串按”加法规则“计算即可，下面是我的几个实现方式： 方法一： 12345678910111213141516171819function addTwoNum(str1, str2){ var carry = 0, l1 = str1.length, l2 = str2.length, arr = []; var max = Math.max(l1, l2); for (var i = l1 - 1, j = l2 -1, n = max -1 ; n &gt;= 0; n--, i--, j--) { var sum = (+str1[i] || 0) + (+str2[j] || 0) + carry; if (sum &gt;= 10) { carry = 1; arr.push(sum - 10); } else { carry = 0; arr.push(sum); } } if (carry &gt; 0) arr.push(carry); return arr.reverse().join('');} 方法二： 1234567891011121314151617181920function addTwoNum(str1, str2){ var arr1 = str1.split('').reverse(); var arr2 = str2.split('').reverse(); var carry = 0, arr = []; var max = Math.max(arr1.length, arr2.length); var min = Math.min(arr1.length, arr2.length); for(var i = 0; i &lt; max; i++){ var tmp = (+arr1[i] || 0) + (+arr2[i] || 0) + carry; if( tmp &gt;= 10){ carry = 1; arr.push(tmp - 10); } else { carry = 0; arr.push(tmp); } } if (carry &gt; 0) arr.push(carry); return arr.reverse().join('');} 如果有错误之处，欢迎指正，谢谢！","link":"/2015/08/25/2015-08-25-how-to-realize-the-two-numbers-together/"},{"title":"最近的一些总结","text":"已经好久没有静下心来写一篇文章了，可能是由于近期一连串的事情影响到了心情吧，也许这只是一个借口而已。今天难得心静了下来，我想是时候回想一下这大半年以来工作和生活状态，同时也借此重新思考，回归初心。 一、生活上这我想从年初和执子闲人一起制订的计划和目标说起，我们在一起也四五年，由于工作时间的差异（大学专业性质的不同），很少能有共同的时间一起吃饭、看电影、逛商场和旅游。因此在年初制订计划的时候优先把工作时间一致性放在第一位（换工作），然后一步一步实现相应的计划，吃西餐、看电影、逛商场、香港旅游、出国旅游等，同时还有一些关于理财与资金管理、学车考驾照、拍婚纱照、锻炼与运动、参加学术讲座等方面的计划。现在想想除了少数几个计划未完成或者正在进行中以外，总体来说还可以，计划完成率通过。 下面我想重点谈论一下其中理财与资金管理这一计划，主要原因有以下几方面： 由于工作相对稳定、资金上有一定的积累以及阅历的丰富，在外界因素的影响下开始感觉应该对金融和理财重新认识。 由于年龄的增长以及相应责任，我们也会开始对婚姻、生活有了重新的认识。希望得到美满的婚姻、高质量的生活。 由于从事的工作以及朋友圈等环境因素的影响和带动下，有强烈的理财需求。 基于以上所述，年初已开始重点关注金融理财方面的知识和动态，先后对各类宝宝进行研究，同时对比P2P理财等各渠道进行分析，最终也进行了股市浪潮，见证了（呜呜）难得一遇的”牛熊之战“。同时经历了股灾的风风雨雨，割舍了金钱收获了成长。 二、 工作上由于对过去的反思和总结，年初重新制订了个人的成长规划 —— 回归初心。本意是想通过回归技术，从心提升专业知识，推动团队和部门更快发展。最终却因以下几件事情有了重大的转变。 外部因素 投入大量的时间关注金融理财和股市 对异常火热的移动互联网未来发展的憧憬 对个人经验以及专业能力的过于自信 内部因素 部门内部原因 公司组织结构的大调整 因结构调整导致大量人员流失 个人发展与规则 综上所述，由于内部因素与外部因素相结合，工作上整体表现不令人满意。这里不在过多的对内外因素做详细的诉说，过去的已经过去了，把握现在抓住机会，重新思考，再次前行。 三、重新开始最近该放下的放下了；该努力争取的争取到了；该留有时间思考的思考了；该静下心来找回自己，找准时机超越自我！ 在部门休整的这段时间里，我大部分时间都是自我反思、项目梳理、代码优化、框架搭建、人员招聘等，空闲的时间多了，对更多的事情有了重新的认识。在以后的时间里我将重点对专业知识、项目管理、人员招聘等方面进行内容的产出。 在这里感谢大家一直以来对我的关注，忍受着我混沌的文章思想以及无养料的产出。在以后的日子里我将更会更加的努力（欢迎各位批评和指正，再次感谢）！","link":"/2015/09/09/2015-09-09-some-of-the-recent-summary/"},{"title":"又一年，又一个岁月，生日快乐","text":"Today is my birthday ! Thank you for your blessing! —— Alan Yi 曾几何时，才搞清楚阴历（农历）和阳历以及星座之间的关系，终于纠正了自己的星座从处女座 —— 天秤座，喔耶！^_^。特殊的日子，平凡的一天，故事即将开始。 在公司下午与同事一起在公司吃完晚餐，回到坐位听着音乐并继续对 smartJs 框架进行开发，当时完全忘记了今天是什么日子。记忆里七点应该还有一位面试同学到来（哦，好吧，后来发现是自己日历时间安排错误）。 在路上回去的地铁上习惯性的和小兵（同事）聊聊今天的股市行情、中国历史、工作情况以及人个想法等等，每次的聊天都很愉快，时间被消遣的也很快，最重要的是学习到了很多东西。 在家里回到家里时被执子闲人问及到手机怎么打不通时，突然想起手机一直没电。刚刚冲了一会儿电，打开手机收到了很多的短信和消息带着祝福和问候！此刻心情异常的激动，顺手记录这特殊的一天。 又一年，又一个岁月，生日快乐！","link":"/2015/09/15/2015-09-15-today-is-my-birthday/"},{"title":"一个Javascript面试题引发的思考","text":"最近一直在负责团队内部前端人员的招聘，前前后后估计也面试了二十几号人，由来自知名互联网、外包公司、非计算机专业、高中毕业生等等。本次不再过多的讨论前端人员面试面经，后面如果有时间的话会针对近期前端招聘详细的分析和总结。这里选取一道笔试题在笔试结果后引发的思考。 Javascript面试题题目：实现一个URI解析方法，把url里#之后的参数解析成指定的数据结构。 12345678910111213141516171819function urlParser(s){ // 答题部分，写出你的代码...}try{ var url1 = &quot;http://www.abc.com/m/s/#page/2/?type=latest_videos&amp;page_size=20&quot;; var url2 = &quot;http://www.abc.com/m/s/#type=latest_videos&amp;page_size=20&quot;; var url3 = &quot;http://www.abc.com/m/s/#page?type=latest_videos&amp;page_size=20&quot;; console.log(urlParser(url1)); console.log(urlParser(url2)); console.log(urlParser(url3)); /*----[执行结果]---- [&quot;page&quot;,&quot;2&quot;,{&quot;type&quot;:&quot;latest_videos&quot;,&quot;page_size&quot;:20}] [{&quot;type&quot;:&quot;latest_videos&quot;, &quot;page_size&quot;:20}] [&quot;page&quot;,{&quot;type&quot;:&quot;latest_videos&quot;,&quot;page_size&quot;:20}] ------------------*/} catch(e){ console.error('执行出错，错误信息：'+e);} 这道笔试题第一眼看上去比较简单，大部分同学的直接反应就是采用字符串分割N次，转换成数组即可。在我的印象中到目前为止，还没有一位同学写出完整的代码。大部分笔试结果如下： 对#,?,&amp;,=,/特殊符号进行分割转换成数组，然后再处理（很少部分能写出来） 对?进行判断，然后进行分割 这题是什么，jquery好像写不出来 工作中没有遇到过，如果真有这需求，百度应该可以 正则应该可以，不知道怎么写 工作了这么多年，还要笔试，不干了 … 这道题目主要是考查对Javascript基本知识、字符串相关操作、数组相关操作、JSON字符串、正则表达式的应用等知识点的掌握程度。 引发的思考通过前面各种笔试的结果分析可以得到以下几大方面的要点： 对基础知识的掌握并能灵活的运用的重要性 思维逻辑的提升、代码的优化等需要长期的自我总结和学习 对事物需从本质思考，深入的学习和理解 工作中态度比能力更重要 那么 =&gt; 基础知识重要还是业务能力重要？ 本身场景不同可能侧重点也就不一样啦，这里主要是我个人的观点：对于个人发展到一定程度可能侧重的方向不再是业务表层，更多的可能是对业务底层或者架构的思考，那么相对来讲就需要对基础知识或者深层掌握更加的重要。 =&gt; 如何提升自己思维逻辑能力、代码组织能力？ 反复阅读基础知识并理解其要领 反复阅读优化的代码并理解其原理 勤动手，多思考 =&gt; 工作年限和工作能力的关系？ 如果工作年限和工作能力是正比，那么你自身的价值会越来越高。否则工作5年和工作2年没有什么区别，需自我反思，认清自己，努力提升自己。 … 在这里我觉得有很多的问题需要自我思考、认清自己、改掉坏习惯、提升自己基础能力。 附个人答案以下是我个人对本题给出的答案，若有误之处，望批评指正！同时也欢迎大家讨论并给出更好的答案。 方法一：字符串分割成数组 12345678910111213141516171819202122232425function urlParser1(s){ // 方法一 var arr = [], obj = {}, strl, strr, hash; // 获取#之后的字符串 hash = s.substring(s.indexOf('#')+1); // 根据?号进行分割成strl和strr,然后单独处理 if(hash.indexOf('?') &gt; -1){ strl = hash.split('?')[0]; strl = strl.lastIndexOf('/') === strl.length-1 ? strl.substring(0, strl.length-1) : strl; arr = strl.split('/'); strr = hash.split('?')[1]; } else { strr = hash; } for(var i = 0, strq = strr.split('&amp;'); i &lt; strq.length; i++){ var tmp = strq[i].split('='); // 对类型进行判断 obj[tmp[0]] = isNaN(tmp[1]) ? tmp[1] : parseInt(tmp[1]); } arr.push(obj); // 转换成字符串JSON数组 return JSON.stringify(arr);} 方法二：正则匹配 123456789101112131415161718192021function urlParser(s){ var arr = [], reg, hash, obj = {}, tmp; // 获取#之后的字符串 hash = s.substring(s.indexOf('#')+1); // 正则匹配关键参数 reg = /(\\w+(?=\\/|\\?))|(\\w+=\\w+)/g; // 奖 key=value 转换成对象 for(var i = 0, rets = hash.match(reg); i &lt; rets.length; i++){ if(rets[i].indexOf('=') &gt; -1){ tmp = rets[i].split('='); // 对类型判断 obj[tmp[0]] = isNaN(tmp[1]) ? tmp[1] : parseInt(tmp[1]); } else { arr.push(rets[i]); } } arr.push(obj); // 转换成字符串JSON数组 return JSON.stringify(arr);} 推荐学习资料 Javascript教程 Javascript高级程序设计第3版 正则表达式速查表","link":"/2015/09/16/2015-09-16-an-interview-questions-of-javascript/"},{"title":"Java和Javascript相互调用的实例","text":"在用HTML5做跨平台应用开发时,尝尝会用到java和js方法互调的问题,对初学者而言,可能会有点难,在这里分享一些自己在实际开发过程中的用法,这里以单点登录的实现方法为例，希望对你有帮助: 首先是java中实现JS方法并实现主动调用JS中方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// Javascript接口类public class SingleLoginJSInterface { private static final String CODE_SUCCESS = &quot;100&quot;; private static final String CODE_CANCEL = &quot;101&quot;; private static final String CODE_GET_TOKEN_ERROR = &quot;102&quot;; private static final String MSG_SUCCESS = &quot;成功&quot;; private static final String MSG_CANCEL = &quot;用户取消&quot;; private static final String MSG_GET_TOKEN_ERROR = &quot;获取token失败&quot;; private static final String CODE = &quot;code&quot;; private static final String MSG = &quot;msg&quot;; private static final String UNAME = &quot;uname&quot;; private static final String UID = &quot;uid&quot;; private static final String TOKEN = &quot;token&quot;; // Javascript接口方法 @JavascriptInterface public void login() { Log.d(&quot;singlesignon&quot;, &quot;login&quot;); final String appId = HttpUtils.getInstance().getAppId(); Log.d(&quot;singlesignon&quot;, &quot;appId:&quot; + appId); Context context = BrowserApplication.getInstance(); GioneeAccount gioneeAccount = GioneeAccount.getInstance(context); gioneeAccount.login(context, appId, new LoginResultListener() { @Override public void onSucess(Object obj) { Log.d(&quot;singlesignon&quot;, &quot;success object:&quot; + obj); handlerResult(obj); } @Override public void onCancel(Object obj) { Log.d(&quot;singlesignon&quot;, &quot;cancel object:&quot; + obj); sendParamsToJS(CODE_CANCEL, MSG_CANCEL); } @Override public void onGetTokenError(Object obj) { Log.d(&quot;singlesignon&quot;, &quot;tokenerror object:&quot; + obj); sendParamsToJS(CODE_GET_TOKEN_ERROR, MSG_GET_TOKEN_ERROR); } private void handlerResult(Object obj) { LoginInfo loginInfo = (LoginInfo) obj; String name = loginInfo.getName(); String uid = loginInfo.getUid(); String token = loginInfo.getToken(); JSONObject object = new JSONObject(); try { object.put(CODE, CODE_SUCCESS); object.put(MSG, MSG_SUCCESS); object.put(UNAME, name); object.put(UID, uid); JSONObject tokenJSON = new JSONObject(token); object.put(TOKEN, tokenJSON); } catch (JSONException e) { Log.d(&quot;singlesignon&quot;, &quot;JSONException&quot;); e.printStackTrace(); } sendParamsToJS(object); } private void sendParamsToJS(String code, String msg) { JSONObject object = new JSONObject(); try { object.put(CODE, code); object.put(MSG, msg); } catch (JSONException e) { e.printStackTrace(); } sendParamsToJS(object); } private void sendParamsToJS(JSONObject object) { Log.d(&quot;singlesignon&quot;, &quot;object:&quot; + object); Controller .getInstance() .getCurrentTab() .getWebView() // java中调用JS的方法 .loadUrl( &quot;javascript:GNBrowser.singleLogin.middleware('&quot; + object + &quot;')&quot;); } }); }} 然后就可以在引用的js文件中直接通过window.SingleLoginJSInterface.login()来直接调用上面的login()方法了. Javascript调用Java中的方法代码封装： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485(function(){ var gnLocalBrowser = { singleLogin: { get: null, support: function(){ return gnLocalBrowser.support('singleLogin'); }, login: function(){ if(this.support().status){ this.support().name.login(); } }, callback: function(){ var that = this; var param = this.getData().token; if(window.singleLoginJumpUrl){ if(window.$ === Zepto || window.$ === jQuery){ $.ajax({ url: window.singleLoginJumpUrl, type: 'get', data: {h:param.h,n:param.n,t:param.t,v:param.v}, dataType: 'json', beforeSend: function(){}, success: function(data){ alert(JSON.stringify(data)); if(data.success){ window.location.reload(); } }, error: function(){ alert('登陆失败，请重新登陆'); } }); } } else { alert('登陆成功，未检测到请求成功的URL！'); } }, middleware: function(data){ // JAVA调用JS的方法 try{ //alert('JSON string is :-------' + data); data = gnLocalBrowser.json2obj(data); //alert('json parse is success.'); } catch(e){ //alert('json format is error.') data = null; } if(data &amp;&amp; data.code === '100'){ this.setData(data); this.callback(); } else { this.loginFail(data); } }, loginFail: function(data){ //alert('登录异常，请重新登录！'); document.title = 'hello world'; }, loginSuccess: function(){ alert('登录成功！'); }, getData: function(){ return this.userData; }, setData: function(data){ this.userData = data; }, }, json2obj: function(json){ return JSON.parse(json); }, support: function(name){ var classMaps = { 'singleLogin': 'SingleLoginJSInterface', }; var status = window[classMaps[name]] !== undefined ? true : false; return {'status': status, 'name': window[classMaps[name]]}; } }; window.GNBrowser = gnLocalBrowser;})();","link":"/2015/12/14/2015-12-14-java-and-javascript-calls-each-other/"},{"title":"Javascript给window.onscroll事件不执行","text":"今天突然收到测试反馈线上网页滚动加载不成功。当时还有点奇怪，之前测试的时候是可以正常加载数据呢！因此决定好好排查一下原因，点击这里查看demo，排查步骤如下： 1234// window.onscroll不能正常执行window.onscroll = function(){ console.log('running');} chrome开发者调试工具下进行断点检测，发现在window.onscroll方法不执行 去除页面上所有脚本，直接执行window.onscroll方法，结果没有输出log 去除页面上所有脚本（js）和样式表（css），直接执行window.onscroll方法，结果可以正确输出log 通过以上排查可以确认样式表对window.onscroll方法执行有影响 最终对样式表进行排查发现当页面最外层元素采用(position:absolute; left:0; right:0; top:0; bottom:0; width:100%;)时且设置样式(overflow:hidden; overflow-x:hidden;)，chrome浏览器window.onscroll会失效，safari浏览器下却可以正常执行。 测试浏览器UA信息如下： 12345// chrome 48.0.2564.97 window.onscroll失效Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.97 Safari/537.36// safari 9.0.2 window.onscroll可以正常执行Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_2) AppleWebKit/601.3.9 (KHTML, like Gecko) Version/9.0.2 Safari/601.3.9 此现象暂时不清楚具体原因，后续补充….","link":"/2016/01/20/2016-01-20-window-onscroll-nothing-to-run/"},{"title":"解决node app.js关闭后显示端口占用","text":"在学习Node开发过程中，经常运行程序（node app.js）时提示端口被占用，信息如下： 123456789101112131415node app.jsevents.js:141 throw er; // Unhandled 'error' event ^Error: listen EADDRINUSE :::3000 at Object.exports._errnoException (util.js:870:11) at exports._exceptionWithHostPort (util.js:893:20) at Server._listen2 (net.js:1236:14) at listen (net.js:1272:10) at Server.listen (net.js:1368:5) at EventEmitter.listen (/Users/hxrealm/www/node_pro/node-test/node_modules/express/lib/application.js:617:24) at Object.&lt;anonymous&gt; (/Users/hxrealm/www/node_pro/node-test/app.js:15:5) at Module._compile (module.js:409:26) at Object.Module._extensions..js (module.js:416:10) at Module.load (module.js:343:32) 此类情况在主要出现在*unix系统下，程序退出时对应的进程未结束，请注意以下几种操作下： mac OS X系统下应该是control + c 而不是 control + z Linux系统下应该是ctrl + c 通过以下命令查看端口被占用的使用： lsof -i:3000 解决端口被占用可以通过以下几种方式： 调用系统自带的进行管理窗口，结束node进程 sudo kill pid 通过lsof -i:3000查看 sudo pkill -9 node 结束所有node进程 sudo npm install -g funckyou，执行funck node可以结束node进程 针对node app.js单一进程管理，重复操作比较繁琐，这里推荐几个node进程管理器： StrongLoop Process Manager PM2 Forever Supervisor 参考资料： cnode上node运行时端口被占用问题的讨论 Express官方推荐的进程管理器","link":"/2016/03/08/2016-03-08-node-error-listen-eaddrinuse/"},{"title":"前端开发工具之Sublime Text的常用插件","text":"sublime text 常用插件 Better CoffeeScript CoffeeComplie DocBlockr EditorConfig EditorConfigSnippets Emmet FileHeader FileSystem Autocmpletion HTML Snippets HTML-CSS-JS Prettify HTML5 JsFormat JSX LESS Markdown Preview Mongoose CoffeeScript React Templates ReacJs Sass SideBarEnhancements SublimeCodeIntel SublimeLiner SublimeTmpl YUI Compressor VUE Formatter VUE Syntax Highlight","link":"/2016/04/20/2016-04-20-frontend-sublime-text3-plugins/"},{"title":"CentOS7下安装Jekyll及配置","text":"这两天购买了linode的vps,通过各种设置后成功安装了CentOS7操作系统，现尝试在CentOS7下安装并使用Jekyll，记录步骤和安装过程中产生的问题和解决方法。 查看系统版本方式一： 1rpm -q rpm -q centos-release // centos-release-7-2.1511.el7.centos.2.10.x86_64 方式二： 1cat /etc/redhat-release // CentOS Linux release 7.2.1511 (Core) 或 1cat /etc/centos-release // CentOS Linux release 7.2.1511 (Core) 安装Ruby123yum install rubyruby -v // ruby 2.0.0p598 (2014-11-13) [x86_64-linux]gem -v // 2.0.14 安装Jekyll通过gem安装Jekyll。因为网络问题需要将国外的镜像替换为国内的镜像（同Windows下的操作相同） 123gem sources --remove https://rubygems.org/gem sources --add https://ruby.taobao.org/gem sources -l // 查看源列表 执行命令 1gem install jekyll 如果出现如下错误 1mkmf.rb can't find header files for ruby at /usr/share/include/ruby.h 安装 ruby-devel 即可解决 1yum install ruby-devel 如果仍出现编译错误，安装以下依赖 1yum install libtool automake autoconf gcc-c++ openssl-devel 至此安装成功 Jekyll创建博客123jekyll new weblogcd weblogjekyll serve 参考资料 jekyllrb Jekyll中文 RubyGems 镜像","link":"/2016/08/20/2016-08-20-install-jekyll-on-centos7/"},{"title":"如何实现HTML标签的转义和反转义","text":"背景在进行web项目开发过程中可能都使用过js的转义和反转义的方法,在此就不再讨论，不清楚的朋友可以查看参考资料中的链接地址。今天主要是讨论如何实现HTML标签的转义和反转义。 还记得很早以前使用 Dreamweaver 开发网页时可以很容易对HTML标签进行转义，自带提示功能和可视化转义功能。常见的HTML字符转义有：&quot; &quot;转义后&amp;nbsp;、&quot;&lt;&quot;转义后&quot;&amp;lt;&quot;、&quot;&gt;&quot;转义后&quot;&amp;gt;&quot;等，对于已经习惯了纯代码编写的前端朋友来说，在不查询HTML字符转义对照表以及第三方工具时，有没有其他办法实现HTML字符的转义呢？ 需求（场景） 前端开发某些特定的功能时需要对用户的输入进行安全检测并对特殊字符进行转义 多端（PC端、client端、移动端）数据来源统一接口时，需要对特殊数据进行字符转义 对多端用户输入的内容进行前端检搜时需对特殊字符进行转义 实现利用innerHTML和innerText对于内容获取和赋值的差异进行操作。innerHTML可以获取和赋值带有HTML标签的内容，而innerText仅能获取纯文本内容，忽略HTML节点标签。所以我们可以先将需要转义的内容赋值给innerText，然后再通过innerHTML获取其内容，这时获取的内容就是转义后的文本。代码如下： HTML标签转义成特殊字符 1234567891011121314&lt;script type=&quot;text/javascript&quot;&gt; // HTML标签转义成特殊字符 function encodeHTML(html){ var output, elem = document.createElement('div'); elem.textContent != null ? (elem.textContent = html) : (elem.innerText = html); output = elem.innerHTML; elem = null; return output; } var str1 = '&lt;p&gt;这里是一段有趣的内容，标签被转义了！&lt;/p&gt;'; // &amp;lt;p&amp;gt;这里是一段有趣的内容，标签被转义了！&amp;lt;/p&amp;gt; console.log(encodeHTML(str1));&lt;/script&gt; 特殊字符转义成HTML标签 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; // 特殊字符转义成HTML标签 function decodeHTML(html){ var output, elem = document.createElement('div'); elem.innerHTML = html; output = elem.innerText || elem.textContent; elem = null; return output; } var str2 = '&amp;lt;p&amp;gt;这里是一段有趣的内容，标签还原了！&amp;lt;/p&amp;gt;'; // &lt;p&gt;这里是一段有趣的内容，标签还原了！&lt;/p&gt; console.log(decodeHTML(str2));&lt;/script&gt; 注：火狐不支持innerText，需要使用textContent属性，而IE早期版本不支持此属性，为了同时兼容IE及火狐，需要进行判断操作，现主流浏览器支持innerText也支持textContent。 参考资料 innerHTML innerText&amp;textContent escape unescape encodeURI decodeURI encodeURIComponent decodeURIComponent","link":"/2016/09/12/2016-09-12-how-to-implement-the-HTML-tags-to-escape-and-escape/"},{"title":"git常用操作命令","text":"一、基本命令查看版本号 1git version 查看帮助 1git help // git or git --help 都可以查看git用法 二、新建本地仓库或clone远程仓库初始化操作 123mkdir &lt;new project&gt; // 创建空项目文件夹cd new-projectgit init 从远程主机克隆一个版本库 1git clone &lt;版本库的网址&gt; // clone下来的，默认是master分支 设置提交者和邮箱 12git config user.name &quot;提交者&quot;git config user.email &quot;test@admin.com&quot; 注：如果需要全局设置git相关用户配置信息可以使用git config –global user.xxx 三、更新至仓库拉取最新代码 1git pull &lt;版本库的分支&gt; // git pull origin master 添加修改的内容到本地缓存 1git add . // 也可以指定文件或目录 提交修改的内容到本地仓库 1git commit -m '提交内容日志' 更新修改的内容至远程仓库 1git push &lt;版本库的分支&gt; // git push origin master 四、管理仓库分支新建本地分支 1git branch &lt;new branch&gt; 在指定分支下新建本地分支 1git checkout -b &lt;new branch&gt; &lt;specified branch&gt; 删除本地分支 1git branch -d &lt;branch&gt; 删除本地分支的引用 1git fetch -p 注：一个远程分支被删除了，可是本地还存在其对应的分支引用，可以通过git fetch -p 删除 删除远程分支 1git branch -r -d &lt;branch&gt; 删除远程分支 1git push origin :branch-name 注意：冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支。 合并分支 1git merge &lt;branch&gt; // 当前分支合并指定分支 撤消添加操作 1234// 撤消添加的指定文件$ git reset filename// 撤消所有添加的操作$ git reset HEAD . 取消本地commit的文件 12git log // 查看日志，并获取需回滚的节点ID:commit_idgit reset --hard commit_id 注：commit_id为需要回滚到的日志ID 当前分支获取另一个分支提交的记录 12345678// 获取分支branch1的提交记录Id$ git checkout branch1// commit 809d95ea1c3d17ed6ba8e25ae2abe15b0f3e737f$ git log// 在分支branch2中重新提交分支branch1中获取的commitId$ git checkout branch2$ git cherry-pick 809d95ea1c3d17ed6ba8e25ae2abe15b0f3e737f 注意：如果提示获取失败（冲突），请按正常处理流程安排。","link":"/2016/09/13/2016-09-13-git-opreation-question/"},{"title":".gitignore设置无效，不能过滤指定文件","text":"通常我们都会利用.gitignore过滤一些特定的文件，例如：系统产生的文件、编译过程中产生的中间文件以及特定的脚本文件（.idea、.DS_store、node_modules、xx.sh）等等，这些文件不需要被追踪管理。 遇到的问题在.gitignore中添加xx.sh文件，以过滤该文件，但是通过git status查看仍显示xx.sh文件的状态。 产生的原因在git库中已存在了这个文件，之前push提交过该文件。 注：.gitignore文件只对还没有加入版本管理的文件起作用，如果之前已经用git把这些文件纳入了版本库，就不起作用了 解决的办法在git库中删除该文件，并更新。再次用git status命令查看状态，xx.sh文件不再显示状态。 注：若该删除的文件为特殊文件，请注意备份。","link":"/2016/10/11/2016-10-11-how-to-use-gitignore/"},{"title":"又一年，又一个岁月，生日快乐","text":"Today is my birthday ! Thank you for your blessing ! —— Alan Yi 今年特别有意思（幸福）农历和阳历整整相差一个月，刚刚休完国庆假期就陆陆续续迎来了爸爸、我和姐姐的生日。在此一一送上我最美好的祝福。 祝：『老爸平平安安，健康长寿！』 祝：『老姐越活越年青，永远十八岁，全家幸福，事事顺心，平平安安！』 祝：『自己开开心心，越来越有担当，收获人生幸福』 致枕边的女神又一年，又一个岁月！越是成长越是觉得时间的短暂！转眼间已到男当娶女当嫁的年龄，在此非常感谢『执子闲人』这些年来一直的陪伴，因你让我的人生变的更精彩。亲爱的『I Love You !』 致尊敬的老爸又一年，又一个岁月！国庆在家待的那几天看到您那黝黑的皮肤、粗糙的老手、干瘦的身躯以及满嘴的假牙，我内心是无比的心痛。不知何时起父亲又多了一丝白发，不知何时父亲的背不在那样挺拔，我不怪岁月带走了您的青春年华，但只求您一生平平安安，健康长寿！ 致亲爱的老姐又一年，又一个岁月！国庆在武汉的短暂相聚是那么的仓促，偷偷的多看了你几眼（^__^），『老姐你也变了』———— 变的没那么有精神了，记得你说你们上班时间长也不区分周末，真的很真辛苦。有时间的时候多出去运动走走，适当的注意养生，希望又一年，又一个岁月能看到不一样的你。 致犹豫的自己又一年，又一个岁月！越是成长越是不那么自信！是时候了，勇敢面对，你一定行的。 最后 生日快乐!","link":"/2016/10/15/2016-10-15-happy-birthday-to-27/"},{"title":"记录一次出差全过程和出差过程中的一些感觉","text":"这次出差来的比较突然，当天上午接到出差任务，中午收拾一下行李后就准备赶赴机场，下面主要记录和分享出差过程中的些节点和产生的感觉。 去往机场由于本次出差待的时间还比较久（两个星期左右）所以需要带的东西比较多，收拾完毕后准备出发。机场距离市区一般都比较远，一般都首选出租车（带发票）、地铁等出行方式。 注：机场候机预留时间最好在一两个小时之间。 到达机场到达机场后主要办理以下业务： 找到对应航空公司办理业务区域 打印登机牌(机票） 打印个人明细（报销） 办理托运（可选） 安检值机 注：火机、易燃易爆物、大于1000ml的冲电宝以及大于100ml的液体和胶状物都不能携带上飞机。但部分物品可以通过托运携带，具体要求以机场规定为准。 候机等待通过安检后就可以安静的等待登机，期间可以听听音乐、看看新闻、电脑办公、机场转转也可以购物或享受美食等。 注：大部分机场都有wifi覆盖。 飞行途中飞机起飞和下落过程中禁止打开手机、电脑以及其他电子设备，飞机正常飞行过程中正常可以使用手机、照相机、电脑等。 注：以上仅做参考，具体要求以航空公司规定为准。 安全抵达飞机安全抵达后大概需要30分钟到1小时左右才可以运送旅客到达机场大厅，请合理的安排接机以及工作行程。 注：飞机抵达后需要一定的时间滑行和运送旅客到达机场大厅以及运送托运行李的时间，请合理安排行程。 园区生活已经在园区生活了几天，整体上感觉园区环境优美、道路干净整洁、生活配套设施齐全、出入安全管理等等，简单的总结为：园林式的办公区域、花园式的生活区域、公园式的活动区域等，给我最深的印象是园区的餐厅————美食繁多，品类齐全，味道可口。因此个人认为园区的活比较还是比较滋润和安逸，生活节奏较慢，下面看看工作日的全天安排： 07:30起床 08:00早餐 08:30打卡（餐厅到办公区域大概5-10分钟的路程） 11:00午餐（不同部门午餐时间有差异） 13:30上班（午餐后可以选择回员工公寓休息一会儿） 17:00下班（项目忙时也会经常加班） 参与各种活动（蓝球、足球、羽毛球等等） 以上是工作日的时间安排表，看着是不是有一种大学生活的节奏（很是羡慕啊有木有），可是出差的这些天还没有享受过这么规律的作息时间安排，由于项目开发任务的需要基本上也是996的生活节奏，但是在环境和生活的影响下，感觉节奏还是挺好的，压力没有那么大（可能是出差的原因吧）。 在非工作时间期间看了几部经典电影《白银帝国》、《黑海夺金》、《中国合伙人》、《泰山归来：险战丛林》等，各种场景的精彩表现，让我们对人性仁义、管理用人、信任与信念、友情与爱情、做人与做事等方面深入思考。 写在最后本文主要还是记录出差的全过程以及在园区的个人感受，同时也通过这段经历和思考让自己在工作和生活上能够做出更做合理的分配以及起到一个的个人推动作用。","link":"/2016/10/23/2016-10-23-about-something-of-in-the-yonyou-industrial-park/"},{"title":"antd 本地部署iconfont正确步骤","text":"Ant Design of React由蚂蚁金服体验技术部出品，是基于React+Redux实现，开发和服务于企业级后台产品。 Ant Design 默认的 iconfont 文件托管在 iconfont.cn 并默认使用平台提供的 alicdn 地址，公网可访问使用。 由于 alicdn 对部分域名有访问限制，或者需要内网环境使用，因此我们可能需要将iconfont文件部署到本地环境。 操作步骤如下： 一、下载iconfont文件 1、官网在线下载 2、字体图标库iconfont中下载 二、部署iconfont服务 通过搭建本地服务器提供iconfont访问地址，例如：http://localhost/iconfont 三、配置@icon-url地址 1、通过package.json中自定义主题参数theme中配置@icon-font为’”iconfont字体本地访问地址”‘ 2、通过引用theme.js的方式自定义主题，配置方式同1 12// 注意：@icon-font地址为字符串，且后面一个iconfont为字体文件名（不需要后缀），地址字符串需要在双引号内'@icon-url': '&quot;http://localhost/iconfont/iconfont&quot;' 参数资料 本地部署iconfont 解决@icon-url无效","link":"/2017/03/24/2017-03-24-antd-local-hosted-iconfont/"},{"title":"注意亚马逊的AWS提供免费一年的套餐到期后扣款","text":"亚马逊应该是目前实际上云服务商中最最知名的，早就听闻了它的云服务器业务，和阿里云的差不多，就是可以自己搭建自己的云服务器。 亚马逊的AWS提供了拥有免费一年的套餐，当时也是为了体验一下AWS，所以就注册并开通了AWS中的EC2，从体验过程中感觉AWS操作相对复杂，不是很适合个体用户，最终还是选择了linode。 今天主要是分享一下亚马逊云服务器取消操作以及在此过程中的一些体会。 背景无意中发现本人信用卡消费记录中有一条Amazon web services扣款$12.19的记录，通过排查发现一年前开通的AWS服务已到期，正常思维是没有使用，不应该产生费用。 调查收集 通过信用卡帐单查询发现AWS服务到期后每月都有不固定的扣款记录 通过登陆AWS官网点击进入帐单与成本管理界面可查询详情消费记录 研究AWS收款规则 关闭服务打开页面: https://console.aws.amazon.com/billing/home#/account (这个页面最下面有提供关闭服务，不会再被收取任何费用，正常情况下直接关闭服务即可) 注：如果开通的不是基础服务则需要先取消相关服务，点击“Cancel Services,” 下面的“Click Here”，点击“Change Plan”，选择“Basic Support” 然后点击“Change Plan”，保存后关闭服务即可","link":"/2017/06/05/2017-06-05-how-to-close-amazon-web-services/"},{"title":"chartjs 在项目应用中的一些总结","text":"Chart.js是一款流行的javascript图表库，基于HTML5 Canvas开发，具有简单、灵活、兼容主流浏览器等特性。 本文主要是对新版Chart.js(v2.0+)在项目应用中的一些小总结，请特别注意目前国内翻译的Chart.js中文版本相对比较旧，大家在使用过程中请注意，在此推荐查看Chart.js官网。 官方版本 Chart.js 中文版本（仅供参考） bootcss chart.js chart.js 中文版 下面主要记录Chart.js在实际项目应用场景中的一些设置，主要以问答方式体现如下： 1、 如何设置线条大小、颜色？ 12345678910data: { labels: labels, datasets: [{ label:'', data, borderWidth: 2, // 线条宽度 borderColor:'rgba(255,255,255,.6)', // 线条颜色 backgroundColor:'rgba(255,255,255,.2)', // 线条到坐标区域背景色 }]} 2、 如何隐藏线条的Tag（标签）？ 在Chart配置参数options中设置legend的dispay的值为false 12345options: { legend: { display: false // 隐藏线条的说明（Tag） }} 3、 如何隐藏对应坐标线以及设置对应坐标线为虚线？ 在Chart配置参数options中对坐标进行相关设置 12345678910111213141516171819202122options: { scales: { xAxes: [{ gridLines:{ display: false, // 隐藏x坐标网格 drawBorder: false, // 不渲染坐标线 } }], yAxes: [{ gridLines:{ display: true, drawBorder: false, drawOnChartArea: true, drawTicks: false, borderDash: [7, 5], // 网络虚线间的空隙 color: 'rgba(255,255,255,.4)', // 网络线颜色 zeroLineBorderDash: [7,5], // 坐标轴上的网络虚线间的空隙 zeroLineColor: 'rgba(255,255,255,.4)' // 线条颜色 } }] }} 4、 如何隐藏y坐标的对应值？ 123456789101112options: { responsive: false, legend: {display: false}, scales: { yAxes: [{ ticks: { display: false, // 隐藏对应坐标的值 min: 0, }, }] } } 5、 如何设置y坐标的最小值？ 默认不设置坐标轴最小值则坐标轴动态显示，可为正数、负数或对等的正负坐标轴，当设置最小值后则按最小值显示对应坐标轴 1234567891011options: { responsive: false, legend: {display: false}, scales: { yAxes: [{ ticks: { min: 100, // 设置Y坐标轴最小值为100 }, }] } } 以下为完整的实例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Chart.defaults.global.defaultFontColor = '#fff'; var myChart = new Chart(ctx, { type: 'line', data: { labels: labels, datasets: [{ label:'', data, pointColor : &quot;#fff&quot;, pointStrokeColor : &quot;#fff&quot;, pointBackgroundColor: '#fff', borderWidth: 2, borderColor:'rgba(255,255,255,.6)', backgroundColor:'rgba(255,255,255,.2)', }] }, options: { responsive: false, legend: {display: false}, scales: { xAxes: [{ gridLines:{ display: false, drawBorder: false, } }], yAxes: [{ ticks: { display: false, min: 0, }, gridLines:{ display: true, drawBorder: false, drawOnChartArea: true, drawTicks: false, borderDash: [7, 5], color: 'rgba(255,255,255,.4)', zeroLineBorderDash: [7,5], zeroLineColor: 'rgba(255,255,255,.4)' } }] } } });","link":"/2017/06/12/2017-06-12-about-use-someing-of-chart/"},{"title":"LazyMan的实现","text":"LazyMan是一道javascript面试题，第一次听说LazyMan一词是与ing70聊天中获得，本文主要是说说自己的实现思路和方法。 题目如下实现一个LazyMan，可以按照以下方式调用: 12345678910111213141516171819LazyMan(&quot;Hank&quot;)输出:Hi! This is Hank!LazyMan(&quot;Hank&quot;).sleep(10).eat(&quot;dinner&quot;)输出Hi! This is Hank!//等待10秒..Wake up after 10Eat dinner~LazyMan(&quot;Hank&quot;).eat(&quot;dinner&quot;).eat(&quot;supper&quot;)输出Hi This is Hank!Eat dinner~Eat supper~LazyMan(&quot;Hank&quot;).sleepFirst(5).eat(&quot;supper&quot;)输出//等待5秒Wake up after 5Hi This is Hank!Eat supper 以此类推。 分析思路根据经验猜测此题可参考jQuery中delay()、PHP中sleep()、Express中next()中间件等方法的实现原理。也是典型的JavaScript流程控制，因此问题的关键是如何实现任务的顺序执行。 考查关键 链式调用 _next()流程控制 定时器的使用(setTimeout) 数组常用方法的掌握(pop、push、shift、unshift) 代码的封装(类、构造函数、原型链等) 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(function(){ function LazyMan(name){ var that = this; this._func = []; // 函数执行任务队列 this.name = name; this._add({info: 'Hi! This is ' + this.name + '!'}); // 下一次事件循环时执行 setTimeout(function(){ that._next(); },0); } // _next维持任务队列中函数的执行 LazyMan.prototype._next = function(){ var func = this._func.shift(); func &amp;&amp; func(); } // 添加任务到队列 LazyMan.prototype._add = function(obj){ var that = this; var fn = function(){ obj.info &amp;&amp; console.log(obj.info); if(obj.time &amp;&amp; obj.time &gt; 0){ setTimeout(function(){ that._next(); }, obj.time * 1000); } else { that._next(); } }; // 添加到队列末端 !!obj.special == false &amp;&amp; this._func.push(fn); // 添加到队列前端 !!obj.special == true &amp;&amp; this._func.unshift(fn); } LazyMan.prototype.eat = function(shit){ this._add({info: 'Eat ' + shit + '~'}); return this; } LazyMan.prototype.sleep = function(time){ this._add({info: 'Wake up after ' + time, time: time, special: false}); return this; } LazyMan.prototype.sleepFirst = function(time){ this._add({info: 'Wake up after ' + time, time: time, special: true}); return this; } var _lazyMan = function(name){ return new LazyMan(name); } window.LazyMan = _lazyMan;})(); 运行结果（在线运行）请打开console控制台，查看运行结果。 See the Pen pwrrjY by hxrealm (@hxrealm) on CodePen.","link":"/2017/06/19/2017-06-19-javascript-lazy-man/"},{"title":"如何正确的提交本地仓库到远程仓库","text":"背景初始化一个本地仓库并添加一个新文件（README.md），然后将本地仓库上传。 先 pull，因为两个项目不同，发现refusing to merge unrelated histories，无法合并。 注：查看解决方法，请直接跳过操作过程。 操作过程新建项目并初始化 123mkdir -p learning/test // 新建一个项目目录cd learning/test // 进入项目目录git init // 初始化仓库 关联远程仓库 1git remote add origin https://git.oschina.net/hxrealm/test.git 查看仓库地址 123$ git remote -vorigin https://git.oschina.net/hxrealm/test.git (fetch)origin https://git.oschina.net/hxrealm/test.git (push) 本地添加README.md并提交 1234touch README.mdgit add README.mdgit commit -m '添加README.md'git push // 提示需设置push到远程仓库对应的分支 git push不成功，按提示操作 12345678910111213$ $ git push --set-upstream origin master // 设置提交的分支$ git push // 继续推送To https://git.oschina.net/hxrealm/test.git ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'https://git.oschina.net/hxrealm/test.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.$ git pull // 拉取数据$ git branch --set-upstream-to=origin/master // 设置仓库分支$ git pull // 继续拉取数据fatal: refusing to merge unrelated histories // 提示合并pull两个不同的项目 原因fatal: refusing to merge unrelated histories 当前模式下本地仓库与远程仓库是两个不同的项目，git pull 合并项目会提示相关信息，添加 –allow-unrelated-histories参数即可解决。 解决1git pull origin master --allow-unrelated-histories","link":"/2017/06/22/2017-06-22-git-FAQ-01/"},{"title":"字母数字排序的sortX的实现","text":"昨天和一个刚刚转前端的朋友聊天时，他说之前面试时有道javascript排序题思路不是很清楚，让我把这道题详细的讲解一下。本文主要是记录我的实现方法，欢迎大家一起讨论，如有更好的方法请给我留言。 题目如下 给定一个只包含大写字母和数字且无重复元素的混合数组，按照以下要求排序 字母按在字母表中的位置和数字从小到大排序 字母优先排在前面 例如： sortX为该方法，则执行sortX([“1”, “A”, “B”, “4”, “E”, “C”, “6”, “7”]); 结果为：[“A”, “1”, “B”, “C”, “4”, “E”, “6”, “7”] 题目分析 主要是查考对javascript基础知识的综合运用能力，主要考查点： 正则的使用 字符串的操作(split、replace) 数组的操作(join、splice、indexOf、push、sort) … 方法实现 12345678910111213141516171819202122var arr = ['1', 'A', 'B', '4', 'E', 'C', '6', '7'];var sortX = function(arr){ var letters = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']; var chars = []; // 存放数组中的字母 // 将字母替换成数字并将数组按从小到大排序 var sorts = arr.join(',').replace(/([A-Z])/g, function($0, $1){ var index = letters.indexOf($1); chars.push($1); return index + 1; }).split(',').sort(function(a,b){return a &gt; b;}); // 将字母替换到排序后的数组中 for(var i = 0; i &lt; chars.length; i++){ var index = letters.indexOf(chars[i]) + 1; var start = sorts.indexOf(index.toString()); sorts.splice(start, 1,chars[i]); } return sorts;}console.log(sortX(arr));// [&quot;A&quot;, &quot;1&quot;, &quot;B&quot;, &quot;C&quot;, &quot;4&quot;, &quot;E&quot;, &quot;6&quot;, &quot;7&quot;] 本题目可实现的方法很多，以上是我认为相对简单的一种实现方法，若你有更好的方法，欢迎给我留言^_^。","link":"/2017/06/25/2017-06-25-javascript-array-sortx/"},{"title":"聚是一团火，散是满天星 -- 新起点","text":"时光的流逝总是在最后那一刻触发心灵最深处的情感，用友-深圳创新中心是梦想与激情的交汇点；是0到1的磨练经历；是一段充实、挑战、愉快的蜕变过程；也是一次过山车的体验（难忘的经历）。 …… 最后“聚是一团火，散是满天星” — 经历风雨，总能见彩虹！","link":"/2017/06/27/2017-06-27-2017-new-starting-point/"},{"title":"Git Flow最流行的代码管理模型","text":"工作至今前前后后也用过了不少版本管理系统例如：CVS、SVN、Mercurial、GIT等，受硬性条件和软性条件因素的影响，不同团队会选择最适合自身的版本管理系统。在这篇文章中主要是介绍互联网型团队（敏捷型团队）中最常用的研发管理体系（gitlab + git + jira or redmine）中的代码分支管理流程 – Git Flow模型。 Git Flow 是什么Git Flow是构建在Git之上的一个组织软件开发活动的模型，是在Git之上构建的一项软件开发最佳实践。Git Flow是一套使用Git进行源代码管理时的一套行为规范和简化部分Git操作的工具。 2010年5月，在一篇名为“一种成功的Git分支模型”的博文中，@nvie介绍了一种在Git之上的软件开发模型。通过利用Git创建和管理分支的能力，为每个分支设定具有特定的含义名称，并将软件生命周期中的各类活动归并到不同的分支上。实现了软件开发过程不同操作的相互隔离。这种软件开发的活动模型被nvie称为“Git Flow”。 一般而言，软件开发模型有常见的瀑布模型、迭代开发模型、以及最近出现的敏捷开发模型等不同的模型。每种模型有各自应用场景。Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git Flow可以很好的于各种现有开发模型相结合使用。 在开始研究Git Flow的具体内容前，下面这张图可以看到模型的全貌（引自nvie的博文)： Git Flow中的分支主分支 对稳定运行的版本进行管理（Tag标记），当运行版本出现bug则采用hotfix分支管理方式进行修复。 1master 开发分支 本地开发环境的主线版本，当有预研功能需求或指定模块优化需求时需采用feature分支管理方式进行处理。 1develop 特性分支或功能分支 主要是针对会影响开发主线版本的功能进行管理，功能开发完后需合并到develop分支。 1feature 验证分支或测试分支 迭代需求在develop分支上开发完成以及开发自测完成后提交全面测试时新建release分支（Tag标记），测试通过后走master分支进行管理否则走develop分支进行管理。所有操作完成后需移除release分支。 1release 热修复分支 master分支运行的版本存在bug时需紧急修复时新建hotfix，修复完成后需合并到devlop和master(Tag标记)，最后移除hotfix分支 1hotfix 以上是一个简版的Git Flow分支的描述，想详细了解Git Flow请点击这里。 参考来源 Git版本控制与工作流 基于git的源代码管理模型——git flow 一种成功的Git分支模型 Git 和 SVN 之间的五个基本区别","link":"/2017/06/28/2017-06-28-git-flow-code-mamagement/"},{"title":"再谈async和defer的区别","text":"我们常用的script标签有两个和性能、js脚本文件下载执行相关的属性:async和defer async的含义【摘自https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script】 该布尔属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于内联脚本无作用 (即没有src属性的脚本） defer的含义【摘自https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/script】 这个布尔属性定义该脚本是否会延迟到文档解析完毕后才执行。 async对于async，相信前端开发的小伙伴们都非常熟悉，很容易让人想到异步处理、非阻塞I/O等场景。在这里async是HTML5 script标签中新增的属性，它的作用是能够异步的加载和执行脚本，不因加载脚本而阻塞页面的加载，一旦加载到就会立即执行。下面让我们一起先看看两个demo： without async with async 简单介绍一下这个demo，一共引用了3个js，1.js和2.js是两个正常的脚本文件，sleep.js是一个延迟5s后执行的阻塞脚本文件。现在我们假设一个场景，一个页面中同时按顺序引入以上3个js脚本文件(1.js、sleep.js、2.js)，现我们希望1.js脚本文件内容执行完后立即执行2.js脚本文件内容，最后执行sleep.js脚本文件内容，应该如何操作？ 下面我们一起看看script标签未指定async属性和指定async属性的前后效果： 未给script标签添加async属性时，正常引入3个js文件，脚本执行效果如下： 当给script标签中引入sleep.js文件行添加async属性后，页面的脚本执行效果如下： defer对于defer，估计“时尚”的前端小同伴可能已经不在使用喽，这个功能还未被所有主流浏览器支持，早期主要是IE内核版本支持，查看详细b了解更多。在这里defer是早期script标签中的属性，它的作用是延迟执行脚本直到文档解析完毕后才执行。下面让我们一起先看看两个demo: without defer with defer 效果同上。 注：可以通过打开浏览器调试工具，查看脚本加载和执行详细过程。 总结 考虑到兼容性，针对低版本浏览器推荐script标签中同时添加async和defer属性 不考虑兼容性，针对主流浏览器推荐script标签中使用async属性 推荐脚本文件在文档的底部引入 参考 携程ued解读defer和async的区别 MDN中文文档","link":"/2017/06/28/2017-07-07-async-and-defer-diff/"},{"title":"HTTP协议版本间的差异化","text":"","link":"/2017/07/15/2017-07-15-http-protocol-version-differences/"},{"title":"web常见的安全问题","text":"本文主要是收集并科普一下web常见的安全问题，针对安全漏洞产生的场景和防御方式不详细的描述(仅作参考)，后续将通过相关系列的文章进行补充和完善。想了解详细的内容，请点击对应的链接进入维基百科查看。持续更新中… 前端安全XSS 跨站脚本攻击 跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 防御措施：过滤特殊字符、使用HTTP头指定类型 CSRF 跨站请求伪造 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 防御措施：检查Referer字段、添加校验token 后端安全SQL注入攻击 SQL攻击（英语：SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 SESSION 与 COOKIE Session 和 Cookie 是两种用于存储用户当前状态的工具。某些开发者不了解 Session 与 Cookie 的区别，误用或者混用，导致敏感信息泄露或者信息篡改。 Cookie 存储在浏览器上，用户可以查看和修改 Cookie。Session 是存储在服务端的数据，一般来说安全可靠；大多数 Session 都是基于 Cookie 实现的（在 Cookie 中存储一串 SESSION_ID，在服务器上存储该 SESSION_ID 对应的内容）。 IP地址欺骗 在计算机网络里面，IP地址欺骗或IP欺骗是一个带有假的源IP地址的IP协议分组（数据报）的产物，目的是隐藏发送方或冒充另一个计算系统身份。使发送方可以保持匿名的一种技术是使用代理服务器。 防御措施：数据报过滤、… 验证码破解 非一次性、易识别性的验证码相对来讲很容易进行破解。 非一次性指的是同一个验证码可以一直被使用下去。一般来说，每进行一次验证码校对（无论正确与否），都应该强制更换或清除 Session 中的验证码。 易识别性指的是不加噪点不加扭曲的验证码，主当技术基本上100%可识别的。 服务器安全DoS/DDoS攻击 拒绝服务攻击（英语：denial-of-service attack，缩写：DoS attack、DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，其称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。 防御措施：防火墙、交换机、路由器、黑洞引导、流量清洗 …","link":"/2017/07/22/2017-07-22-common-web-security-issues/"},{"title":"四年前的旧版个人博客在Heroku中正常运行","text":"今天在新网中更新个人域名DNS解析时，无意中发现四年前上传到Heroku云平台上的基于Node开发的个人博客（旧版）仍在正常运行，WoW，真是一件令人高兴的事情。 Heroku是什么Heroku是一个支持多种编程语言的云平台。支持Ruby、Java、Node.js、Scala、Clojure、Python、PHP、Perl等开发语言，了解更多。 Heroku中如何部署Node应用程序Heroku官方在线文档很完善，推荐大家直接在线阅读传送门，也可以查看很早之前我写的一篇相关文章Ubuntu下通过Heroku部署Node.js应用程序，里面有详细的介绍。 国内各大云平台最近几年随着Node开发的火热，国内各大云平台也都支持了Node相关环境的部署，主要平台有： 新浪云 阿里云 百度云 腾讯云 早期我主要用过新浪云、百度云、阿里云部署过Node小应用程序，从体验角度来讲的话，阿里云的兼容性和可操作性较好，但每个平台都有各自的特点，大家可根据自身要求进行选择。 最后，大家有任何问题，欢迎共同交流。","link":"/2017/07/22/2017-07-25-a-surprising-thing-in-the-heroku/"},{"title":"深入浅出 ES6 Promise （一）","text":"最近这几年随着移动互联网的快速发展，前端的开发模式已悄悄地从多页面混合开发模式到单页面前后端分离开发模式的转变，基于MVVM模式的前端框架得到了繁荣发展。它们主要是knockoutjs、reactjs、angularjs、vuejs等，其中尤雨溪开发的vuejs框架在国内得到开发者的认可和支持。 基于MVVM模式开发的框架能得到快速的发展主要得益于2015年6月份ES2015的正式发布（也就是ES6），其中Promise被列为正式规范，作为ES6中最重要的特性之一，我们有必要掌握并理解透彻。本文将由浅到深，讲解Promise的基本概念与使用方法。 基本概念Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义。一个诺言，一个成功，一个失败。) 常用方法 Promise.all() Promise.prototype.catch() Promise.prototype.then() Promise.race() Promise.reject() Promise.resolve() 新手入门 控制台中查看Promise真身 1console.log(Promise) 可知：Promise是一个构造函数，有all、race、reject、resolve四个静态方法以及then和catch两个公共方法。 实例化一个Promise对象 1234567var p1 = new Promise(function(resolve, reject){ //做一些异步操作 setTimeout(function(){ console.log('异步中执行完成'); resolve('异步中传递数据'); }, 1000);}); 可知：Promise的构造函数接受一个executor参数，executor是一个带有resolve和reject两个参数的函数。executor 函数在Promise构造函数执行时同步执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled(完成)或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，1秒后，输出“异步中执行完成”，并且调用resolve方法。 then() 方法的使用 步骤2中我们实例化了一个Promise对象p1并且我们在setTimeout执行中调用了resolve方法，重置了Promise状态为resolved。 如何调用then() 方法？ 123456p1.then(function(data){ // resolve状态 console.log(data); // 异步中传递数据}, function(data){ // reject状态，仅在Promise异步执行中调用reject方法后重置Promise状态为rejected时生效}); 可知：then() 方法主要接受resolve和reject参数，且两个参数都是函数。仅当Promise状态为resolved时调用reslove函数，状态为rejected时调用reject函数 catch() 方法的使用 catch() 方法返回一个Promise，只处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。但catch() 方法可以捕获异常错误，因此catch() 方法主要用做捕获抛出的错误。 如何调用catch() 方法呢？ 123p1.catch(function(reason){ // 拒绝}) 可知：catch() 方法接受reason参数，如果 onRejected 抛出一个错误或返回一个失败的 Promise，Promise 通过 catch() 返回失败结果；否则，它将显示为成功。 示例： 使用链式语句的 catch方法 1234567891011121314151617181920212223242526var p1 = new Promise(function(resolve, reject) { resolve('Success');});p1.then(function(value) { console.log(value); // &quot;成功!&quot; throw 'oh, no!';}).catch(function(e) { console.log(e); // &quot;oh, no!&quot;}).then(function(){ console.log('after a catch the chain is restored');}, function () { console.log('Not fired due to the catch');});// 以下行为与上述相同p1.then(function(value) { console.log(value); // &quot;成功!&quot; return Promise.reject('oh, no!');}).catch(function(e) { console.log(e); // &quot;oh, no!&quot;}).then(function(){ console.log('after a catch the chain is restored');}, function () { console.log('Not fired due to the catch');}); 捕获抛出的错误 12345678// 抛出一个错误，大多数时候将调用catch方法var p1 = new Promise(function(resolve, reject) { throw 'Uh-oh!';});p1.catch(function(e) { console.log(e); // &quot;Uh-oh!&quot;}); all() 方法的使用 Promise.all(iterable) 方法提供了并行执行异步操作的能力，当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。 12345678910111213141516171819202122232425262728293031var p1 = new Promise(function(resolve, reject){ // 异步操作 setTimeout(function(){ resolve('传递数据01'); }, 1000);});var p2 = new Promise(function(resolve, reject){ // 异步操作 setTimeout(function(){ resolve('传递数据02'); }, 1000);});var p3 = new Promise(function(resolve, reject){ // 异步操作 setTimeout(function(){ resolve('传递数据03'); }, 1000);});// 全部resolved状态Promise.all([p1, p2, p3]).then(function(values){ console.log(values); // [&quot;传递数据01&quot;, &quot;传递数据02&quot;, &quot;传递数据03&quot;]});// p2,p3异步操作时调用reject() 方法// 则返回第一个rejected状态的PromisePromise.all([p1, p2, p3]).catch(function(values){ console.log(values); // &quot;传递数据02&quot;}); 可知：Promise.all() 方法接受一个数组参数，数组参数中的每一项都是一个Promise对象。执行过程中如果有任何一项是rejected状态则返回当前项Promise否则全部resloved状态后返回Promise。 race() 方法的使用 race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。 1234567891011var p1 = new Promise(function(resolve, reject) { setTimeout(resolve, 500, &quot;one&quot;); });var p2 = new Promise(function(resolve, reject) { setTimeout(resolve, 100, &quot;two&quot;); });Promise.race([p1, p2]).then(function(value) { console.log(value); // &quot;two&quot; // 两个都完成，但 p2 更快}); reject() 方法的使用 静态函数Promise.reject返回一个被拒绝的Promise。使用是Error实例的reason对调试和选择性错误捕捉很有帮助。 1234567891011Promise.reject(&quot;Testing static reject&quot;).then(function(reason) { // 未被调用}, function(reason) { console.log(reason); // &quot;测试静态拒绝&quot;});Promise.reject(new Error(&quot;fail&quot;)).then(function(error) { // 未被调用}, function(error) { console.log(error); // 堆栈跟踪}); resolve() 方法的使用 Promise.resolve(value)方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。 使用静态方法Promise.resolve 12345Promise.resolve(&quot;Success&quot;).then(function(value) { console.log(value); // &quot;Success&quot;}, function(value) { // 不会被调用}); 对一个数组进行resolve 1234var p = Promise.resolve([1,2,3]);p.then(function(v) { console.log(v[0]); // 1}); Resolve另一个promise对象 12345var original = Promise.resolve(true);var cast = Promise.resolve(original);cast.then(function(v) { console.log(v); // true}); resolve thenable的对象们并抛出错误 123456789101112131415161718192021222324252627282930313233343536373839// Resolve一个thenable对象var p1 = Promise.resolve({ then: function(onFulfill, onReject) { onFulfill(&quot;fulfilled!&quot;); }});console.log(p1 instanceof Promise) // true, 这是一个Promise对象p1.then(function(v) { console.log(v); // 输出&quot;fulfilled!&quot; }, function(e) { // 不会被调用});// Thenable在callback之前抛出异常// Promise rejectsvar thenable = { then: function(resolve) { throw new TypeError(&quot;Throwing&quot;); resolve(&quot;Resolving&quot;);}};var p2 = Promise.resolve(thenable);p2.then(function(v) { // 不会被调用}, function(e) { console.log(e); // TypeError: Throwing});// Thenable在callback之后抛出异常// Promise resolvesvar thenable = { then: function(resolve) { resolve(&quot;Resolving&quot;); throw new TypeError(&quot;Throwing&quot;);}};var p3 = Promise.resolve(thenable);p3.then(function(v) { console.log(v); // 输出&quot;Resolving&quot;}, function(e) { // 不会被调用}); 总结本篇文章主要是简单的介绍了Promise概念以及Promise常用方法的使用。文中所有异步操作均以setTimeout为例子，之所以不使用ajax是为了避免引起混淆，因为谈起ajax，很多人的第一反应就是jquery的ajax，而jquery又有自己的Promise实现。如果你理解了原理，就知道使用setTimeout和使用ajax是一样的意思。 接下来还会有深入浅出 ES6 Promise讲解系列： Promise 使用以及运用场景 Promise/A+规范 搞懂jQuery中的Promise 搞懂Promise、Generator、Async三者的异同 Promise 面试问题讲解 参考 Promises/A Promises/A+ Promises/A+规范 Promise对象/阮一峰 Promise对象/MDN 面试中Promise相关问题","link":"/2017/07/26/2017-07-26-promise-of-chapter-1th/"},{"title":"论在互联网金融公司工作的新体验","text":"最近在公司接受了蛮多的培训和分享，对互联网金融有了较新的认识。由此也就想写一篇关于（技术人员）在互联网金融公司工作的新体验，以此来对比（回顾）一下和普通互联网的工作的不同体验。对比指标仅参考个人曾工作或熟知的公司，不做行业间公司的相关指标对比。 工作时间相比于普通互联网公司，在互联网金融公司工作时间更加的弹性化和人性化，例如：上班时间：8:30 ~ 10:00 下班时间：16:30 ~ 18:00 加班时间：正常不多，感觉还是挻赞的有木有^_^。 工作文化相比于普通互联网公司，在互联网金融公司工作文化方面有诸多的差异： 在工作环境上大同小异，可能金融元素会体现的多一些； 在研发模式上基本上也没有什么差别，但在敏捷迭代、前后端分离、持续集成、数据分析和数据安全等方面有较多的积累，其中前端：node + express + swig + angular/react/vue 后端：java 管理：BitBucket + JIRA + Confluence + Jenkins； 在研发流程上基本上也是遵循着需求评审-UX评审-UI评审-研发阶段-测试阶段-验收阶段-正式发布这一常规流程，但其中有两个重要的角色-产品经理和项目经理，相比于普通互联网公司可能缺少项目经理这一角色，同时对研发阶段、测试阶段和发布阶段有较多的case规范； 在研发过程中还是有一些差异，主要有：a. 详细的迭代任务卡 b. 详细的迭代操作记录 c. 严格的代码review d. 完善的接口文档 e. 各种丰富的工具集 企业文化相比于普通互联网公司，在互联网金融公司会有较多的金融小知识、安全开发、信息安全意识和网络安全等多方面的培训学习来增强大家的自我防范和自我保护意识。 写在最后互联网金融公司由其特有的性质，直接或间接面对金钱相关，因此在生活和工作各方面要时刻保持高度地自我防范意识，避免造成不必要的麻烦。做到在生活过程中要有主动的自我防范意识，不讨论或透露任何与工作相关的内容；在工作过程中尽量使用公司许可的正版软件或开源的自由软件；在开发过程中要注意代码质量同时也要注意代码安全和代码性能问题；在做技术方案或者技术选型过程中也要考虑是否存在技术使用上的风险问题，尽可能的选择开源技术，避免产生不确定的外在因素。 以上内容仅表达个人观点，感觉写的也不是很全面，时间允许的话后面再慢慢完善吧！","link":"/2017/08/27/2017-08-27-A-new-experience-in-the-work-of-Internet-finance-companies/"},{"title":"关于点融黑帮","text":"点融黑帮是什么？点融黑帮——点融网的核心技术团队。 一个快速发展的团队，一群志同道合的人。 这里，实实在在，真心做事，平心做人。 我们在做什么？我们在用技术创新改变传统金融，我们希望改变世界，我们需要你能用你的力量，让更多人，更幸福地、更好地生活在这个地球上。 点融黑帮在哪 ？现位于上海黄浦区8号桥4期办公区，环境舒适优雅。 点融黑帮是群什么样的人？在这里与帅哥美女一起共事，这里没有办公室政治，没有乏味的会议——全部都是热爱生活，热爱旅行的小伙伴。 动不动骑行大半个中国的PHP大神，一个人背包走过丝路的前端女神，放弃300万年薪环游世界的投行大牛，他们是最酷的小伙伴！ 听听他们对我们怎么说？创始人Soul说一个公司、一个人最重要的是 to be honest ，然而，我的前任企业们都做不到，而这对我来说，很重要。点融黑帮无论何事都能说到做到，这让我很是安心也很佩服。 —Andrew 来到点融前，3年半的时间，我有2次创业，烧了投资人几百万。当时很深的体会，凭个人能力真的很难做大事。点融也算一眼相中，来了之后，发现没来错，因为这里空间很大，队友很强，很多在原来看来很困难的事在这就成了。 —Max 开放的文化提供了创新和突破的土壤。大学里，经历了从社会学到计算机的跨专业挑战；工作后，又一次尝试从研究员到开发运维的转型。点融黑帮打造了一个完全开放的工作平台，让我敢于尝试和挑战，发现无尽的可能和未知的精彩。 —Tony","link":"/2017/09/14/2017-09-14-about-dianrong-mafia/"},{"title":"一件令人痛心的事","text":"朋友圈中第一眼看到那熟悉的名字(欧某某)后我详细的看完了那篇文章，令我非常震惊同时瞬间心里感觉很失落！想想就特别的难过，一位这么好朋友真的走了T_T！ 两周前我们还通过电话联络着感情，没想到这是最后一次听到他的声音，他的为人特别好相处，是一位好领导、好同事、好朋友。 回想当年进入ZTE时的情景，再到从ZTE出来时的选择，欧经理都给了我很多的建议和帮助，至此让我找到前进的方向。 最后 请接受我真诚的感谢，您的帮助我将永远铭记！ 愿真相得以还原，愿逝者安息！","link":"/2017/12/14/2017-12-14-a-sad-thing/"},{"title":"HTTP请求中GET方法传递数组问题的讲解","text":"背景介绍在某前后端分离的项目中有一个根据用户的选择（可多选）查询相关记录的需求，后端接口由Backend(java)提供。接口格式类似如http://www.domain.com/query?checked=1&amp;checked=2&amp;checked=3，可知其中QueryString的参数为checked=1&amp;checked=2&amp;checked=3。前端为了实现需求将该字段的key定义为checked，value定义为1&amp;cheked=2&amp;checked=3的字符串，生成**{checked: “1&amp;checked=2&amp;checked=3”}**的一个对象做为参数，验证结果发现后端不能正常接收到checked的参数。 关键要点 前后端分离的项目采用了接口代理（request、http proxy） Backend接口中定义checked为一个枚举类型 (checked) 前端数据对象中key不要相同，因此只能采用字符串方式 过程分析1、检验GET请求参数值 1通过断点调试查看业务逻辑处理过程中生成的GET请求参数值为checked=1&amp;checked=2&amp;checked=3 2、检验接口代理层收到GET请求参数值 1通过断点调试查看接口代理层接收到的GET请求参数值为checked=1&amp;checked=2&amp;checked=3 3、检验接口代理层发送时GET请求参数值 1通过断点调试查看接口代理层发送时GET请求参数值变为checked[0]=1&amp;checked[1]=2&amp;checked[2]=3 4、检验后端接收GET请求参数值 1通过与后端联调发现参数接收异常，不能正常解析checked[0]=1&amp;checked[1]=2&amp;checked[2]=3为枚举类型 通过以上几个步骤的排查发现HTTP GET请求在经过proxy时多个相同的键值对(checked)会被解析为不同的数组项，其主要原因是对QueryString进行参数解析时引入的qs模块会进行相同的键值对转数组项操作。 解决方法 修改为POST请求进行数组参数传递 修改为GET请求是数组值以逗号等形式分割的字符串传递（checked=1,2,3） 后端主动支持对数组项字符串的解析 写在最后此问题在发现到排查以及最终解决花了不少时间，其实主要还是前端和后端人员对HTTP协议过程中数据传递的原理理解不同，如果大家能达成一致，快速给出应对方案，此问题将非常容易处理。","link":"/2017/12/29/2017-12-27-how-to-debug-that-send-an-array-with-an-http-get/"},{"title":"2017年终总结","text":"一年又过去了，每到年终总想写点什么来记录过去规划未来，不然总感觉有点不自在。 以下是今年的总结： 一、拥有第一辆车入手了人生第一辆B级小轿车，提前实现了30岁前的一个小目标。 二、与爱相伴一生结束了七年爱情之路的漫跑，走进了婚姻的殿堂。让终将迎来花儿盛开的时刻，此生愿与你相伴到老，愿此后的每一天能带给亲爱的甜蜜的快乐！ 三、旅行点亮地图一年间不经意的也去过了北京、昆明、大理、丽江、深圳、东莞、广州、厦门、晋江、九江等城市，亲临奇境，总会有不一样的感受。放飞心情，方能享受！ 四、家人幸福相随爸妈给哥带小孩总算能有机会出来看看外面的世界，在这一年里家人相聚的次数明显很多，有家人的地方就是幸福。记得暑假的时候把姐姐和姐夫一家人接过来玩了几天，看到小孩子们灿烂的笑容，感觉很开心，很满足。愿以后的日子里家人能够更和谐，共同维护好这最浓的关系！有家人在，就有幸福！ 五、新工作新挑战在工作上这一年感触特别深，发生了很多事情，同时也经历了很多，在这里也不想详谈。给我印象比较深刻的还是在用友那一年半左右的时间里，经历了创业期、合并期、产出期、衰退期等几个阶段的考验，跟坐过山车一样，有惊险、很刺激，其实最终想想还是有很多的收获。 六、最后本篇总结写的很简短，感觉17年接触和经历的事情特别的多，涉及到不同领域、不同方向的话题特别的多，但是在写这篇文章的时候我却没有什么思路。对于新的一年，有了很多新的动力、新的方向、新的规划，不断的加强自我管理，实现自我突破！ 最后世界很美好，现实也“可以不残酷”！加油！！","link":"/2018/01/02/2018-01-02-summary-of-the-year/"},{"title":"博客从Jekyll迁移到Hexo","text":"博客从刚开始的Wordpress迁移到Jekyll那都是发生在2014年的事，到现在已经四年了。在这段时间里确实发生了很多事情，近段时间静下心来想想得到了一些感想，我认为“过去的就让它过去，现在重新认识自己，也来得及改变自己！”。 这两天花了几个小时的时间将博客从Jekyll迁移到Hexo，这里主要记录一下操作过程。 建站按以下命令安装Hexo并初始化blog项目，这里默认用户机已安装node运行环境。 12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 迁移把*_posts文件夹内的所有文件复制到source/_posts文件夹，并在_config.yml*中修改 new_post_name参数。 1new_post_name: :year-:month-:day-:title.md 主题项目初始化时默认采用landscape的主题，由于时间的关系我直接从官方主题库中选择了一款简约风格的hexo-theme-Anatole主题。 将hexo-theme-Anatole主题下载后放到themes目录，并在*_config.yml修改theme*参数。 1theme: hexo-theme-Anatole 部署这里主要是采用GitHub Pages的模式托管静态博客。 1、新建仓库 登录GitHub并在新建仓库页面新建blog仓库。 2、配置参数 在本项目*_config.yml文件中配置deploy*下的参数，例如： 1234deploy: type: git repo: https://github.com/username/blog branch: gh-pages 3、绑定域名 在source目录下新建CNAME文件，请输入个人域名，例如： 1www.domain.com 4、配置DNS 这里以DNSPod为例，在DNS解析模块添加以下记录： 123主机记录 记录类型 记录值@ CNAME username.github.iowww CNAME username.github.io 或 1234主机记录 记录类型 记录值@ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io 注：对DNS的配置不是立即生效的，过10分钟再去访问你的域名看看有没有配置成功 : ) 5、一键部署 1hexo deploy 大功告成^_^，更多的部署方式以及详细介绍，请点击这里","link":"/2018/05/31/2018-05-31-blog-migration-from-jekyll-to-hexo/"},{"title":"你一定知道的Git分支模型","text":"本文不是一篇 Git 入门指南也不是对 Git 命令行使用技巧的讲解，而是谈谈作者在过往工作中使用的几种代码版本管理工具的一些体会，同时重点讲解一下 Git 的分支模型。 注：本文中涉及到的图片均来源于互联网。 背景谈论到代码版本控制，相信大家在项目开发过程中或多或少都有使用过 SVN 和 Git。对代码的更新、提交、合并等操作都非常的熟悉，但是许多人对如何在项目中选择适合的代码管理工具以及对应的工作流却不是很清楚。 最近刚好在团队内组织了一次以”一个成功的 Git 分支模型“为主题的分享活动，旨在同大家一起回顾一下过往项目中使用几种代码版本管理的经历及体会，并以此来讨论 Git 分支模型的适用场景，现将 PPT 中主要内容进行梳理，以内容输出的方式供大家了解。 版本管理工具项目开发过程中大家可能使用比较多的版本管理工具有：VisualSVN、TortoiseSVN、Bazzar、Mercurial、Git、Bitkeeper等等。 其中VisualSVN、TortoiseSVN、Bazzar为集中式版本控制系统，Mercurial、Git、Bitkeeper为分布式版本控制系统。 集中式 VS 分布式版本控制 集中式版本控制的优点在于可以对具体的文件或目录进行权限控制，缺点在于通过与中心服务器连接执行所有操作，必须联网。 分布式版本控制的优点具体如下： 分支管理 安全性更高（因为每个客户机本地都有保留完整的版本库） 离线工作，操作便捷（不联网也能照常工作） 可以实现非常灵活的工作流组合（后面有介绍 Git 工作流） 分布式版本控制的缺点由于分布式的特性，很难对版本库中具体的文件或者目录做精细的权限控制。 到这里相信大家已经对版本控制工具有了一个大致的了解，下面让我们一起来看看本文的重点内容 — Git 分支模型。 首先，让我们先了解一下 Git 是什么？Git(读音为/gɪt/。)是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。 其次，让我们知道 有哪些 Git 代码托管平台？国内常见的 Git 代码托管平台有码云（Gitee）、码市（Coding）等，国外常见的代码托管平台有 Github、Bitbucket、Gitlab、VSTS 等。 最后，让我们一起来看看 有哪些 Git 工作流？ Centralized (集中式工作流) Feature Branch （功能分支工作流） Gitflow （Gitflow 工作流） Fork （Fork 工作流） 集中式工作流集中式工作流（Centralized）是以中央仓库作为项目所有修改的单点实体。所有新功能的开发都是基于一个叫master分支进行。 举个例子： 1、小明开始开发新功能 2、小红开始开发新功能 3、小明完成新功能开发，并提交到 master 分支 4、小红完成新功能开发，并提交到 master 分支，此时提示与小明的内容产生冲突，小红提交不了代码，现在很苦恼！ 5、小强发现并及时的帮助小红rebase了本地的master分支获取了最新代码 1git pull --rebase origin master 6、在小强的帮助下，小红也可以提交新功能开发到 master 分支 1git push origin master 在这件事之后小红和小明的关系越走越远，跟小强的人际关系越走越近。 功能分支工作流 该工作流中每个用户都基于 master 分支创建一个新的功能分支，相比于集中式工作流会更加的安全以及产生更低的冲突率。 基于master分支 123git checkout mastergit fetch origingit reset --hard origin/master 创建新分支 1git checkout -b new-feature master 举个例子： 小强和小红在同一个项目组，现在合作开发一个项目，项目的主分支为master。 小红创建一个新分支 1git checkout -b xh-feature master 中午到了，小红提交了本地的修改信息并通知到小强后去吃午饭 123git add .git commit -m 'add commit'git push origin xh-feature 午饭过后，小红合并了新分支到 master 并提交至远程仓库 123git checkout mastergit merge xh-featuregit push origin master 下午小强获取小红的代码后发现其开发的功能需求不对，通知小红更新 小红重新修改功能需求后，提交修改并发布 Fork 工作流该工作流不同于其他类型的工作流，它主要是通过在第三方代码托管平台上进行 Fork 一个开源项目到自己的仓库中。与 clone 方式不同，clone 主要是对目标仓库数据的一次拷贝。 Git Flow 工作流Git Flow 工作流仍然用中央仓库作为所有开发者的交互中心。和其它的工作流一样，开发者在本地工作并 push 分支到要中央仓库中。 Git Flow 工作流使用 2 个分支来记录项目的历史。master 分支存储了正式发布的历史，而 develop 分支作为功能的集成分支。这样也方便 master 分支上的所有提交分配一个版本号。 主要分支： master（主干分支，可用于产线正式发布） hotfix（维护/热修复分支，基于master分支上存在的问题快速修复分支） release（发布分支，可用于测试版本发布） develop（开发分支，可用于开发迭代） feature（功能分支，可用于个体开发和协作开发） 分支模型的工作原理功能分支 123456789// 创建功能分支git checkout -b feature/feature-name develop// 合并到develop分支git checkout developgit merge feature/feature-name// 删除功能分支git branch -d feature/feature-name 发布分支 12345678910111213// 创建release分支git checkout -b release/release-name develop// 合并到master分支git checkout mastergit merge release/release-name// 合并到develop分支git checkout developgit merge release/release-name// 删除release分支git branch -d release/release-name 热修复分支 12345678910111213// 创建hotfix分支git checkout -b hotfix/hotfix-name master// 合并到master分支git checkout mastergit merge hotfix/hotfix-name// 合并到develop分支git checkout developgit merge hotfix/hotfix-name// 删除hotfix分支git branch -d hotfix/hotfix-name git-flow 工具集git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。 基本命令用法 简单实例： 12// Git Flow 模型初始化git flow init 12345678// 新建特性分支git flow feature start feature-name// 发布特性分支git flow feature publish feature-name// 合并特性分支git flow feature finish feature-name 12345// 新建发布分支git flow release start release-name// 合并发布分支git flow release finish v1.0.0 –m “tag message“ 12345// 新建热修复分支git flow hotfix start hotfix-name// 合并热修复分支git flow hotfix finish v1.0.1 写在最后本篇文章内容信息量较大，整理过程中难免会有些纰漏，欢迎大家指正。如需要了解更多相关内容请详细查看参考资料部分的链接地址。 参考资料 Git SCM Git-flow Git branching model Comparing Workflows Git-flow cheat sheet","link":"/2018/06/06/2018-06-08-you-must-know-the-git-branching-model/"},{"title":"2018年终总结","text":"2018年即将过去，2019即将到来。在倒计时的最后两个小时，我想对2018年做一下回顾与总结。 原本以为2018寓意着“要发”，会沿着个人预期的轨迹嘀嗒嘀嗒的旋转，实际上却是按照逆预期的轨迹在旋转着，虽然结果不是很美好，但是过程很有意义。 下面我将从家庭、生活、工作三方面做一下简单的回顾与总结，主要内容如下： 家庭爸爸和妈妈成为深圳上班一族2018年某天爸爸和妈妈在没有娃带的情况开始闲不住了，陆续在深圳找了一份工作，从此成为了”上班族”。说老实话我的心里有点酸也不是很赞成年迈的老爸(60+岁)和老妈（55+岁）在这个年龄阶段还去上班，但是当妈妈说：“趁现在还有机会，我想出去走走看看，感受一下生活”时，我同意了。毕竟老妈之前一直待农村，没有怎么看看外面的世界。 2019年希望能有更多的时间陪陪老爸老妈，也希望他们身体健健康康。 理财与亏损，又一次血的教训2018年依然秉持着对家庭理财的重视，涉足了多种理财渠道，包括但不限于银行理财、基金、保险、股票、P2P等。 回想一下2018年，经历了很多，包括但不限于股票信息欺骗、P2P爆雷、股市”黑天鹅“、基金持续亏损等，在此不一一展开，经历多了，总能收获一点价值。 2019年希望能够扭转亏损，在专业上能够进一步得到提升。 能陪伴亲人，也是一种幸福2018年下半年的某天突然接到大舅子打来的电话说：“妈不行了，急需转院，你跟我姐说一下”，听到这里我心里很沉重，没有过多久又接到了老婆的电话（哭泣声）说：“我妈病的很严重，可能都见不到她了，你赶紧买票”。此时真真切切的感受到了生命的可贵。 急匆匆的买完票，坐火车赶到泉州华侨医院已经是晚上十一点多了，第一眼看到老妈时感觉她是那么的憔悴，和家人沟通了解到老妈病情暂时还算稳定，现在正在等待安排病房。这时心里稍微放下了点。 晚上我和老婆决定守夜照顾老妈，这一决定持续到了医生肯定的说：“病情得到了控制，没有尽一步恶化的话，再观察几天就可以办理出院”。此时已经连续五天四夜了，在这段时间是我估计是和老爸老妈待的最长的一段时间，有许多的感受。 对亲人的任何付出都是值得\b\b，能够陪伴你们真的很幸福。 2019年希望老爸老妈能够注意生活习惯，健健康康，同时也希望家人都能和和睦睦。 生活坚持运动，养成良好的习惯2018年相比以往运动上有了小步的提升，主要运动包括：健身运动、打羽毛球、游泳、爬山、跑步。 2018年开车的足迹遍布9+市，感觉到了各地的美食、人文、自然风光。 2018年是习惯养成的初年，之前的恶习必须改掉，养成良好的习惯，才能承载好的身体。 2019年坚持运动，养成良好的习惯。 积极调整心态，生活更美好2018年遇到了很多事情，有预期的、也有不预期的，要来的终究都来了，积极面对，调整好心态，一切都过去了。 2019年，积极调整心态，迎接我美好的生活^–^ 工作当计划赶不上变化时，请拥抱变化在2018年的工作过程中有比较深的体会，当没有主动权或者撑控权时请积极拥抱变化，适时做出调整。 管理是一门技术，更是一门艺术2018年在团队管理方面遇到了很多问题，在团队管理模式上我采用了较多的尝试。总体来说还是有得有失。 2019年认真对待这门技术，认真对待这门艺术！ 聚是一团火，散是满天星2018年12月24日，聚是一团火，散是满天星。 写在最后2018年真的是感受特别多的一年，有很多可写，也有很多不想写的地方。在亲情、友情、爱情方方面面都获得了思考和学习。 2019年带着思考和学习的心态，努力前进！ 2018年没有预期中的顺利，但是结果也没有想象中的那么差，2019再出发，愿一切都安好。","link":"/2018/12/31/2018-year/"},{"title":"2019，你好","text":"新的一年，对我个人来说应该是很特别、很有意义、甚至是收获惊喜的一年。 在新的一年里，我想用几个关键字来进行表达我内心的想法：积极、乐观、塑造、沉淀、共享。 积极行动积极行动起来，认真对待人和事，保持积极向上的心态。 心态乐观遇到问题不急不躁，对待问题的结果保持良好的心态。 塑造形象一直一来想根据自身条件，塑造一个个人形象，19年我想是时候了。 积累沉淀毕业后工作也已经有些年限了，期间接触过很多的人和事，产生了很多的感悟。我想”一个字，就是干“，比较适合当前阶段的想法。带着思考做事情，并进行有效的沉淀。 共享价值将这些年攒下的经验进行梳理和总结，通过网络渠道共享给有需要的人，我相信这本身也是一件很有意义的事。 写在最后这个篇文章可能显得不是那么通畅或有料，其实本文更多是我最内一时的想法，其中关键的内容并没有明显得表述出来。 后面我将通过行动的方式来达成以上的想法，希望能看到一个全新的自己。","link":"/2019/01/04/2019-hello/"},{"title":"浏览器弹窗拦截机制解剖","text":"上一篇文章《在浏览器新窗口中打开的几种方式》介绍了在浏览器中打开新窗口的一些场景，但没有提到在浏览器中打开新窗口时会遇到弹窗被拦截（或阻止）的情况。 本篇文章将从浏览器弹窗拦截（或阻止）机制的原理、按步骤重现浏览器弹窗被拦截的场景以及实现如何绕过浏览器弹窗拦截。 弹窗拦截的机制浏览器安全机制中，页面弹窗，必须是在用户触发的，才算合法弹窗；由ajax或定时执行的弹窗均为非用户触发。会被浏览器或相关安全软件理解为广告被拦截掉； 弹窗拦截的场景通过点击（ajax）获取后端返回的参数，其中部分参数会在在打开新窗口中进行页面跳转时使用。例如：自动登录（单点登录）、文件下载（权限控制）等等。 场景一1234567891011121314151617&lt;a id=&quot;J_autoLogin&quot; href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;自动登录&lt;/a&gt;&lt;script&gt;function openNewWin(){ $.ajax({ url: 'url', type: 'POST', dataType: 'json', data: {key: 'value'}, success: function(data){ // callback中打开新窗口 var url = data.url || '/'; window.open(url, '_blank'); } })} &lt;/script&gt; 场景二1234567891011121314151617181920212223242526&lt;a id=&quot;J_autoLogin&quot; href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;自动登录&lt;/a&gt;&lt;script&gt;function openNewWin() { $.ajax({ url: 'url', type: 'POST', dataType: 'json', data: {key: 'value'}, success: function(data){ var url = data.url || '/'; // 模拟用户点击跳转 gotoURL(url); } })}function gotoURL(url){ var elem = document.createElement('a'); elem.setAttribute('href', url); elem.setAttribute('target', '_blank'); elem.style.display = 'none'; elem.innerText = '临时使用的链接'; document.body.appendChild(elem); elem.click();}&lt;/script&gt; 场景三123456789101112131415161718192021&lt;a id=&quot;J_autoLogin&quot; href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;自动登录&lt;/a&gt;&lt;form id=&quot;J_loginForm&quot; method=&quot;GET&quot; action=&quot;#&quot; target=&quot;_blank&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&quot; /&gt;&lt;/form&gt;&lt;script&gt;function openNewWin() { $.ajax({ url: 'url', type: 'POST', dataType: 'json', data: {key: 'value'}, success: function(data){ var url = data.url || '/'; // 自动提交表单 $('#J_loginForm').attr('action', url); $('#J_loginForm input[name=token]').val(data.token); $('#J_loginForm').submit(); } })}&lt;/script&gt; 绕过拦截的方法方法一123456789101112131415161718&lt;a href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;点击弹窗&lt;/a&gt;&lt;script&gt;function openNewWin() { //先发起弹窗（因为是用户触发，所以不会被拦截） var popup = window.open('about:blank', '_blank'); $.ajax({ url: 'url', type: 'POST', dataType: 'json', data: {key: 'value'}, success: function(data){ //在重定向页面链接 popup.location = data.url; } })} &lt;/script&gt; 注：页面ajax弹窗为一次性操作。意思就是：从发起弹窗，到最后的重定向，一整套流程必须是一条线流程。如ajax成功后，做相关用户体验交互的校验（比如只有当校验成功才跳转），那该方法会影响页面交互，具体可自行测试。 方法二123456789101112131415161718&lt;a href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;点击弹窗&lt;/a&gt;&lt;script&gt;function openNewWin(){ $.ajax({ url: 'url', type: 'POST', dataType: 'json', // 将异步修改为同步 async: false, data: {key: 'value'}, success: function(data){ //发起弹窗 window.open(data.url, '_blank'); } })} &lt;/script&gt; 注：实测能解决大部分浏览器的拦截问题，但是解决不了安全软件的拦截（360不会拦截，但是QQ管家会拦截） 方法三12345678910111213141516171819202122232425262728293031&lt;a href=&quot;javascript:;&quot; onclick=&quot;openNewWin();&quot;&gt;点击弹窗&lt;/a&gt;&lt;script&gt;function openNewWin(){ $.ajax({ url: 'url', type: 'POST', dataType: 'json', // ajax为同步 async: false, data: {key: 'value'}, success: function(data){ // 模拟用户点击 var url = data.url || '/'; gotoURL(url); } })} function gotoURL(url){ //生成一个临时链接对象 var link = $('&lt;a href=&quot;'+ url +'&quot; target=&quot;_blank&quot; style=&quot;display: none;&quot;&gt;临时链接&lt;/a&gt;'); var elem = a.get(0); var evt = document.createEvent('MouseEvents'); //模拟点击操作 evt.initEvent( 'click', true, true ); elem.dispatchEvent(e); // 点击后移除该对象 link.remove();}&lt;/script&gt; 注：目前该方法亲测有效，可通过浏览器和安全软件；但所有浏览器兼容性未检测，请自行检测！ 写在最后浏览器弹窗被拦截主要还是非用户直接操作（异步请求或定时执行）所产生的。解决弹窗被拦截的方法主要是修改异步请求为同步请求以及模拟用户自动事件触发。","link":"/2018/06/19/browser-pop-interception-mechanism-to-explain/"},{"title":"“好好干前端” -- 公众号正式运营","text":"2019年，就是好好干。 官宣今天正式开通微信个人公众号“好好干前端”和掘金个人专栏，欢迎各位捧个场给个关注或者star。 写在后面博客继续全面承担个人生活、情感、工作、技术等方方面面的内容，公众号和掘金专栏将承担个人在技术方面的学习和沉淀方面的内容，主要以技术研究和内容输出为主。 最后，感谢大家的支持！","link":"/2019/01/08/let's-do-the-frontend/"},{"title":"在浏览器新窗口中打开的几种方式","text":"场景在前端业务开发过程中，需要从浏览器新窗口中打开的场景其实也有很多，下面一起来看看，实际应用场景，如下： 1、访问网站内部链接在本窗口打开，访问网站外部链接在新窗口打开 html: 12// 内部链接地址，本窗口跳转&lt;a href=&quot;//www.hanyi.pro/blog/about&quot;&gt;关于我&lt;/a&gt; 12// 外部链接地址，新窗口打开&lt;a href=&quot;https://github.com/hxrealm&quot; target=&quot;_blank&quot;&gt;Github&lt;/a&gt; 2、站内搜索，将表单数据提交到新窗口中查询 html: 1234&lt;form method=&quot;GET&quot; action=&quot;http://www.baidu.com/s&quot; target=&quot;_blank&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;wd&quot; value=&quot;hxrealm&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;search&quot; value=&quot;submit&quot; /&gt;&lt;/form&gt; 3、点击操作，弹出一个固定窗口 html: 1&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;打开新窗口&lt;/button&gt; javascript: 123456&lt;script type=&quot;text/javascript&quot;&gt; var btn = document.getElementById('btn'); btn.onclick = function(){ window.open(&quot;http://www.baidu.com/&quot;, &quot;_blank&quot;,&quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, width=400, height=400&quot;) }&lt;/script&gt; 4、事件模拟，自动触发 html: 12&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;打开新窗口&lt;/button&gt;&lt;a id=&quot;link&quot; href=&quot;http://www.baidu.com/&quot; _target=&quot;block&quot;&gt;&lt;/a&gt; javascript: 1234567&lt;script type=&quot;text/javascript&quot;&gt; var link = document.getElementById('link'); var btn = document.getElementById('btn'); btn.onclick = function(){ link.click(); }&lt;/script&gt; 或者 123456&lt;script type=&quot;text/javascript&quot;&gt; var link = document.getElementById('link'); var evt = document.createEvent('MouseEvents'); evt.initEvent(&quot;click&quot;, true, true); link.dispatchEvent(evt);&lt;/script&gt; 5、右键点击链接，选择新窗口中打开 写在最后以上都是常见的在浏览器中打开新窗口的方式，其中针对js事件打开新窗口的方法还存在很多种组合方式，在此没有一一列举。 在实际的业务场景中，还有一种情况经常会遇到，那就是弹窗被浏览器阻止了，需要通过设置弹窗不被阻止放后正常打开。 那么其中的原理和发生的场景是什么以及如何绕过浏览器（chrome）的弹窗拦截机制，请看下篇文章《浏览器弹窗拦截机制解剖》。","link":"/2018/06/14/open-a-new-window-in-the-browser/"},{"title":"前端进阶系列（第1期）：理解JavaScript数据类型","text":"写在前面前端进阶系列本着“好好干前端”的心态，一步一个脚印认真练好前端的基本功，为在前端的发展道路上做好铺垫。 本周正式开始前端进阶的第1期，本周的主题是理解JavaScript数据类型。 数据类型最新的 ECMAScript 标准定义了7种数据类型，主要分为两大类基本类型和引用类型。 基本类型基本类型有时也被称为值类型或原始类型。其中包括6种数据类型，分别是：字符串类型（String）、数字类型（Number）、布尔类型（Boolean）、对空类型（Null）、未定义类型（Undefined）、符号类型（Symbol）。 字符串类型JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量。 数字类型根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(263 -1) 到 263 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)。 1234567123; // 正整数-123; // 负整数520.1314; // 浮点数0; // 零Infinity; // 正无穷-Infinity; // 负无穷typeof Infinity; // number 布尔类型布尔表示一个逻辑实体，可以有两个值：true 和 false。 1234562 &gt; 1; // true[] == []; // false [] == ![]; // true 这是为什么？null == undefined // true'10' &gt; '3'; // flase 这个啥？typeof true; // boolean Null 类型Null 类型只有一个值： null。 12null === null; // truetypeof null; // object 为什么不是 null呢？ Undefined 类型一个没有被赋值的变量会有个默认值 undefined。 123456let a; // 我申明我是一个变量 atypeof a; // undefined 申明未赋值undefined == undefined; // trueundefined == 0; // falseundefined == null; // trueundefined == ''; // false 符号类型符号(Symbols)是ECMAScript 第6版新定义的。符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值。 1234567891011121314let obj = {};let symbol1 = Symbol();let symbol2 = Symbol();typeof symbol1; // symboltypeof symbol2; // symbolsymbol1 == symbol2; // falseobj.symbol1 = 'hello';obj[symbol1] = 'world';console.log(obj.symbol1 + ' ' + obj[symbol1]); // hello world 引用类型引用类型主是指Object类型。 Object 对象在计算机科学中, 对象是指内存中的可以被 标识符引用的一块区域。 1234567891011let obj1 = {}; // 对象字面量let obj2 = new Object(); // 实例化一个对象typeof obj1; // objecttypeof obj2; // objectconst person = { author: {name: &quot;布一&quot;, &quot;wechat&quot;: &quot;hxrealm&quot;}, 1: &quot;No.1&quot; };console.log(person.author.name); // 布一console.log(person.author.wechat); // hxrealmconsole.log(person[1]); // No.1 类型对比我们都知道JavaScript中有两大数据类型：基本类型和引用类型，其中基本类型主要是把值存储在栈内存中，而引用类型却是把地址存储在栈内存中，把值存储在堆内存中，然后将栈内存中存储的地址指向堆内存中存储的值。 基本类型 数据结构 存储位置 基本类型 数字、字符串、布尔、Null、Undefined、Symbol 栈 引用类型 数组、对象、函数 栈、堆 什么是堆栈？堆栈是两种数据结构，是一种数据项按序排列的数据结构，只能在一端进行插入和删除操作。堆为队列优先，先进先出（FIFO）。栈为先进后出（FILO）。 堆和栈有啥区别？ 空间分配 堆（操作系统）：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收，分配方式类似于链表。PS：java中都是系统GC，程序员无法进行GC。 栈（操作系统）：由操作系统自动分配释放，存放函数的参数值，局部变量值等。操作方式与数据结构中的栈相类似。 缓存方式 堆：使用二级缓存，生命周期与虚拟机的GC算法有关（并不是引用为空就立即被GC），调用速度相对较低。 栈：使用一级缓存，被调用时通常处于存储空间中，调用后被立即释放。 数据结构 堆（数据结构）：类似于树结构，可以类比于堆排序 栈（数据结构）：先进后出（FILO） 总结本篇文章内容主要告诉我们以下几个基本知识点： JavaScript中有7种数据类型，分为两大类：基本类型和引用类型。 堆和栈的概念和区别，以及JavaScript中两大数据类型的存储方式。 抛出了一些数据类型转换时遇到的“奇葩”问题。 针对第3点我们将在下一章节中重点讲解。 参考资料 JavaScript 数据类型和数据结构 操作系统中堆（heap）与栈（stack）的区别","link":"/2019/01/27/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%88%E7%AC%AC1%E6%9C%9F%EF%BC%89%EF%BC%9A%E7%90%86%E8%A7%A3JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"前端进阶系列（第3期）：常见的面试题 — 隐式类型转换","text":"通过阅读前面几期的内容，我们已经知道了JavaScript中的数据类型以及其在运算时进行隐式转换过程。 本期我们将重点分析一下面试过程中常见的隐式类型转换的面试题。 1. 加号操作请输出代码运行的结果并说明原理？ 1234console.log(1 + undefined)console.log(1 + null)console.log(1 + true)console.log('hello' + 123) 分析：通过加号运算符进行运算，存在两种情况，第一种是字符串与加号运算符组成字符串连接操作，第二种是非字符串与加号运算符组成算术运算操作（需要将对应项转换成Number类型后进行操作） 答案： 1234console.log(1 + undefined) // NaNconsole.log(1 + null) // 1console.log(1 + true) // 2console.log('hello' + 123) // 'hello123' 2. 字符串间的比较请输出代码运行的结果并说明原理？ 1234console.log('a' &gt; 'b')console.log('abc' &gt; 'abe')console.log('10' &gt; '2')console.log('hello' &gt; 'world') 分析：字符串的比较是按位进行，将对应位的字符转换成ASCII码的值进行大小比较。 举个例子： 12345console.log('10' &gt; '2') // false// 等同于console.log('1'.charCodeAt()) // 49console.log('2'.charCodeAt()) // 50console.log('1'.charCodeAt() &gt; '2'.charCodeAt()) // 49 &gt; 50 答案： 1234console.log('a' &gt; 'b') // trueconsole.log('abc' &gt; 'abe') // falseconsole.log('10' &gt; '2') // falseconsole.log('hello' &gt; 'world') // false 3. 引用类型之间的比较请输出代码运行的结果并说明原理？ 123console.log([] == [])console.log([] == ![])console.log({} == {}) 分析：引用类型之间的比较会直接调用valueOf()返回的值进行比较，如果返回值是基本类型则转换成number类型进行比较，否则判断返回值的引用地址是否一致，如果一致收相等否则不相等。 举个例子： 123456console.log([] == ![]) // 为什么[] == ![]会为true呢？// 等同于//第一步![]转成Boolean类型console.log([] == !Boolean([])) // [] == false// 第二步转成Number类型再进行关系运算console.log(Number([]) == Number(false)) // 0 == 0 答案： 123console.log([] == []) // falseconsole.log([] == ![]) // trueconsole.log({} == {}) // false 4. 逻辑非以及其关系运算请输出代码运行的结果并说明原理？ 1234567891011121314// 布尔值判断console.log(!![])console.log(!!{})console.log(!!'hello')console.log(!!123)console.log(!!-123)console.log(!!0)console.log(!!'')console.log(!!null)console.log(!!undefined)// 关系运算console.log(1 == true)console.log(1 &gt; null)console.log(1 &gt; undefined) 分析：在JavaScript中逻辑非会调用Boolean转换，但是在关系运算过程中会将值转换成Number类型再进行比较。 答案： 1234567891011121314// 布尔值判断console.log(!![]) // trueconsole.log(!!{}) // trueconsole.log(!!'hello') // trueconsole.log(!!123) // trueconsole.log(!!-123) // trueconsole.log(!!0) // falseconsole.log(!!'') // falseconsole.log(!!null) // falseconsole.log(!!undefined) // false// 关系运算console.log(1 == true) // trueconsole.log(1 &gt; null) // trueconsole.log(1 &gt; undefined) // true 5. 浮点数相加请输出代码运行的结果并说明原理？ 1console.log(0.1 + 0.2) 分析：这是一个浮点数计算精度问题，在JavaScript中只有一个数字类型number，而number使用的是IEEE 754双精度浮点格式。详细的分析请见下期专题分析。 答案： 1console.log(0.1 + 0.2) // 结果是 0.30000000000000004，而不是 0.3 6. 特殊情况请输出代码运行的结果并说明原理？ 1234567891011console.log(null == undefined)console.log(null == 0)console.log(null == '')console.log(null == NaN)console.log(undefined == 0)console.log(undefined == '')console.log(undefined == NaN)console.log(NaN == 0)console.log(NaN == '')console.log(NaN == NaN)console.log(0 == '') 分析：主要是考查对JavaScript中原始值的理解。 null特指对象的值未设置 undefined指一个原始值自动分配给刚刚声明的变量或没有实际参数的形式参数 NaN是（Not a Number）的缩写，当一个值不能被Number转换时返回NaN，NaN不等于任何值 0是原始值为0的数字 ‘’是原始值为空的字符串 答案： 1234567891011console.log(null == undefined) // trueconsole.log(null == 0) // falseconsole.log(null == '') // falseconsole.log(null == NaN) // falseconsole.log(undefined == 0) // falseconsole.log(undefined == '') // falseconsole.log(undefined == NaN) // falseconsole.log(NaN == 0) // falseconsole.log(NaN == '') // falseconsole.log(NaN == NaN) // falseconsole.log(0 == '') // true 以上内容虽然有进行验证，但不知道描述上是否存在歧义，有些点表述的不是很清楚，望谅解。 如果有发现任何问题或者有更好的建议，欢迎直接给我留言。","link":"/2019/02/11/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%88%E7%AC%AC3%E6%9C%9F%EF%BC%89%EF%BC%9A%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%20%E2%80%94%20%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"前端进阶系列（第4期）：JavaScript中一切皆为对象揭秘","text":"写在前面以前在阅读《JavaScript高级语言程序设计》中有提到“在JavaScript中，一切皆为对象”，当时并没有深入理解其真正的含义，现在想想其内含着很大的信息量，下面跟着我一步一步的揭开其神秘的面纱。 第一步：类型检测在JavaScript中通过typeof进行数据类型检测。 运行以下代码： 12345678910console.log(typeof undefined); // undefinedconsole.log(typeof ''); // stringconsole.log(typeof 123); // numberconsole.log(typeof true); // booleanconsole.log(typeof Symbol()); // symbolconsole.log(typeof function() {}); // functionconsole.log(typeof []); // objectconsole.log(typeof {}); // objectconsole.log(typeof null); // objectconsole.log(typeof new Number(123)); // object 根据上面代码输出结果可知，除开基本类型，typeof输出的其它的都是function和object，即引用类型。 第二步：函数是对象吗？首先通过instanceof检验一下函数是不是Object的实例。 运行以下代码： 12345const func = function(a, b) { return a + b;}console.log(func instanceof Object); // true 根据上面代码输出结果可知，函数 function 也是对象。 如果大家注意到的话，其实上面的代码等同于 运行以下代码： 1234const func = new Function('a', 'b', 'return a + b');console.log(func instanceof Function); // trueconsole.log(func instanceof Object); // true 根据上面代码输出结果可知，函数 func 既是 Function 的实例又是 Object 的实例。 第三步：常见的内置对象其实在JavaScript中有很多的内置对象，例如：Number、String、Boolean、Symbol、Array、Function、RegExp、Object、JSON、Date、Set、Map、Error、Math等等，了解更多请点击这里。 运行以下代码： 12345678910111213141516171819202122232425262728293031323334// 实例化数字对象const num = new Number(123);console.log(typeof Number); // functionconsole.log(typeof num); // object// 实例化字符串对象const str = new String('hello world');console.log(typeof String); // functionconsole.log(typeof str); // object// Symbol是函数且不能被new 实例化const smb = new Symbol('smb'); // TypeError Symbol 不能实例化console.log(typeof Symbol); // function// Math 内置对象const max = Math.max(1,5); // 直接调用该类型的静态方法console.log(typeof Math); // object// 实例化数组对象const arr = [1,2,3,4];console.log(typeof Array); // functionconsole.log(typeof arr); // object// 实例化对象const obj = {name: '布一', wechat: 'hxrealm'};console.log(typeof Object); // functionconsole.log(typeof obj); // object// 自定义一个函数const Func = function() {}const func = new Func();console.log(typeof Func); // functionconsole.log(typeof func); // object 根据上面代码输出结果可知，对象是通过函数来创建的，而函数却又是一种对象。 注：实例化一个对象不一定非要new一个对象。 对象格式通常的对象（Object），一般是利用键值对表示的，例如下面这样： 12345678const obj = { name: '布一', age: 18, wechat: 'hxrealm', getName: function() { return this.name; }} 那数组和函数不也是对象吗，它们也可以这样表示？ 当然不可以，但它们可以采用另一种表示形式。如函数，可以这样： 123456const func = function() {}func.description = 'JavaScript function';func.getName = function() { return this.description;} 写在最后总之，在javascript的世界里，一切皆为对象，且对象就是属性的集合。 最后抛出一个问题，函数 function 为什么是对象 Object 的实例以及它们之间有什么关联？ 如果有发现任何问题或者有更好的建议，欢迎直接给我留言。 交流更多精彩内容请关注https://github.com/hxrealm/blog,如果你觉得还不错请给个star，非常感谢。","link":"/2019/02/15/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%88%E7%AC%AC4%E6%9C%9F%EF%BC%89%EF%BC%9AJavaScript%E4%B8%AD%E4%B8%80%E5%88%87%E7%9A%86%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%8F%AD%E7%A7%98/"},{"title":"推荐几款实用的chrome插件","text":"一直想找个时间好好地回顾和总结一下开发过程中一些实用的东西，最近项目正好不是很忙，就此先梳理其中的一部分分享给大家。 好了废话不多说了，这次主要是给大家推荐几个我自己一直在使用的 Chrome 插件，逼格很高而且还非常实用。 1. Proxy SwitchyOmega科学上网必备，你懂得，而且也很方便进行代理相关的配置。 传送门 Proxy SwitchyOmega 插件 2. Adblock PlusAdblock Plus 是一款非常出色的 chrome 广告屏蔽插件，可以帮助用户屏蔽在浏览网页时的各种烦人广告。 传送门 Adblock Plus 官网 Adblock Plus 插件 3. Eyecare Assistant保护眼睛的一款好插件，修改网页背景色为豆沙绿，更加护眼，随时开启/关闭。 传送门 Eyecare Assistant crx 下载 4. Momentum在同事的电脑上看到它的第一眼就被深深的吸引了，太 TM 的炫酷了。用它我们可以创建一个炫酷的新标签页，高清背景图+TODO，绝对美观+实用。不信我们来看看？ 你的 chrome 打开是这样子的 酷不酷我就不说了，你们自己觉得，关键是每一天都不一样，而且还可以添加 todoList 更多功能你们可以自行探索，因为下面还有更重要的推荐给你们，这才是刚开始，你们就激动的不行了。 传送门 Momentum 官网 Momentum 插件 5. OneTabOneTab 这个插件绝对牛逼，对我们技术人员来讲真是犹如神助啊，我们在工作中难免在开发的过程中查阅资料，打开很多标签页但是又舍不得关闭，最主要的是浏览器的标签页打开了来以后不仅影响我们查找，还非常占用电脑的内存，使我们的电脑非常卡。 有了 OneTab 这些根本就不是问题了，它可以帮你把所有标签页都收集到一个标签里，而且还能释放我们的内存，当我们需要的时候可以单独或全部恢复它们。就是这么简单，粗暴。 传送门 OneTab 官网 OneTab 插件 6. The Great Suspender这款插件也非常的实用，可以让打开的某个标签页进行冻结也可以设定一个时长让标签自动冻结，这样就可以很方便的控制那些暂时用不到的 Tab 标签页，达到系统资源释放，你有没有 GET 到点，是不是很棒。 The Great Suspender 插件 7. Google Translate谷歌翻译插件，非常实用。 传送门 Google Translate 官网 Google Translate 插件 8. Isometric Contributions这个插件绝对是程序员专属了，它可以让我们 Github 的贡献图变成 3D 效果，非常适合用来装逼有没有，是不是很高大上。 传送门 Isometric Contributions 插件 9. JSONView一直在使用的一款 JSON 格式化插件，项目联调开发过程中查看 api 接口时非常好用。 传送门 JSONView 插件 10. 简繁转换工具推荐这个插件主要是针对于项目需要国际化语言包时针对简繁体转换操作。 传送门 简繁转换工具插件","link":"/2018/11/13/recommended-several-practical-chrome-plugin/"},{"title":"前端进阶系列（第2期）：深入理解JavaScript数据类型转换","text":"上一期中我们主要是了解了JavaScript中存在两大数据类型：基本类型和引用类型以及其存储的方式（堆和栈）。 本期我们将重点谈谈JavaScript数据类型转换过程出现的各种“奇葩”的问题。 写在前面在JavaScript中当运算符在运算时，如果两边数据不统一，CPU就无法计算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成一样的数据类型再计算，这种无需程序员手动转换，而由编译器自动转换的方式就称为隐式转换。 在JavaScript中“一切皆是对象”，在我们具体了解隐式转换前先了解一下对象的两个方法：toString()和valueOf()。 toString()toString() 方法返回一个表示该对象的字符串。 12345678910111213141516// 数字转字符串(123).toString() // '123'// 布尔值转字符串(true).toString() // 'true'// 数组转字符串['hello', 'world'].toString() // 'hello,world'// 对象转字符串({name: 'hello world'}).toString() // '[object Object]'//日期对象转字符串Date().toString() // 'Wed Jan 23 2019 21:10:42 GMT+0800 (China Standard Time)'//JSON对象转字符串JSON.toString() // '[object JSON]'// Function转字符串Function.toString() // 'function Function() { [native code] }'// 函数转字符串(function(){ return 1; }).toString() // 'function () { return 1; }' valueOf()valueOf() 方法返回指定对象的原始值。 JavaScript调用valueOf方法将对象转换为原始值。你很少需要自己调用valueOf方法；当遇到要预期的原始值的对象时，JavaScript会自动调用它。 默认情况下，valueOf方法由Object后面的每个对象继承。 每个内置的核心对象都会覆盖此方法以返回适当的值。如果对象没有原始值，则valueOf将返回对象本身。 JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。 12345678910111213141516// 数字的原始值(123).valueOf() // 123// 布尔值的原始值(true).valueOf() // true// 数组的原始值['hello', 'world'].valueOf() // [ 'hello', 'world' ]// 对象的原始值({name: 'hello world'}).valueOf() // { name: 'hello world' }//日期对象的原始值Date().valueOf() // 'Wed Jan 23 2019 21:10:42 GMT+0800 (China Standard Time)'//JSON的原始值JSON.valueOf() // 'Object [JSON] {}'// Function的原始值Function.valueOf() // '[Function: Function]'// 函数的原始值(function func(){ return 1; }).valueOf() // '[Function: func]' 隐式转换规则 转成string类型：+（字符串连接符） 转成number类型：++/–(自增或自减运算符)、+ - * / % (算术运算符)、&gt; &lt; &gt;= &lt;= == != === !== (关系运算符) 转成boolean类型：！（逻辑非运算符） 字符串 VS 加号连接符字符串 + 基本类型 = 字符串 + String(基本类型) 12345678// 字符串 + 数字console.log('hello' + 123) // 'hello' + '123'// 字符串 + 布尔console.log('hello' + true) // 'hello' + 'true'// 字符串 + nullconsole.log('hello' + null) // 'hello' + 'null'// 字符串 + undefinedconsole.log('hello' + undefined) // 'hello' + 'undefined' 数字 VS 加号连接符数字 + 基本类型（非字符串） = 数字类型 + Number(基本类型) 123456789101112// 数字 + 布尔console.log(1 + true) // 2// 等同于console.log(1 + Number(true)) // 1 + 1// 数字 + undefinedconsole.log(1 + undefined) // NaN// 等同于console.log(1 + Number(undefined)) // 1 + NaN// 数字 + nullconsole.log(1 + null) // 1// 等同于console.log(1 + Number(null)) // 1 + 0 数字 + 引用类型 = 数字 + 引用类型.toString() 12345678// 数字 + 数组console.log(1 + []) // '1'// 等同于console.log(1 + [].toString()) // 1 + '' = '1'// 数字 + 对象console.log(1 + {}) // '1[object Object]'// 等同于console.log(1 + ({}).toString()) // 1 + '[object Object]' 数字类型 + 函数 = 数字类型 + String(函数) 123// 数字 + 函数var func = function() { var a = 2; return 2; }console.log(1 + func); // 1function () {var a = 2; return 2;} 关系运算符的隐式转换规则：将其他数据类型转换成数字类型之后再比较关系 1234567891011121314151617181920// 字符串 vs 数字 = Number(字符串) vs 数字console.log('2' &gt; 10); // flase// 等同于console.log(Number('2') &gt; 10) // 2 &gt; 10// 字符串（数字） vs 字符串（数字） = ASCII码（对应值） vs ASCII码（对应值）console.log('2' &gt; '10'); // true// 等同于console.log('2'.charCodeAt() &gt; '10'.charCodeAt) // 50 &gt; 49// 字符串（字母） vs 字符串（字母） = ASCII码（对应值） vs ASCII码（对应值）console.log('abc' &gt; 'b'); // false// 等同于console.log('abc'.charCodeAt() &gt; 'b'.charCodeAt()) // 97 &gt; 98// NaN 不等于 NaNconsole.log(NaN == NaN) // false// undefined vs nullconsole.log(undefined == null) // true//注意：undefined == null 不等同于console.log(Number(undefined) == Number(null)) // false NaN == 0// 这里JavaScript的特殊约定的结果，undefined == null,详情可以查看更多资料// https://codeburst.io/javascript-null-vs-undefined-20f955215a2 逻辑非与关系运算符的隐式转换123456789101112131415161718// 数字 vs 数组 = 数字 vs Number(数组)console.log([] == 0); // true// 等同于console.log(Number([]) == 0) // 0 == 0// 数字 vs 布尔 = 数字 vs Number(布尔)console.log(![] == 0); //true// 等同于console.log(Number(![]) == 0) // Number(false) == 0 // 引用类型 != 引用类型console.log([] == []); // false// 逻辑非隐式转换console.log([] == ![]); // true// 等同于console.log(Number([]) == Number(!Boolean([]))) // 0 == 0// 逻辑非隐式转换console.log({} == !{}); // false// 等同于console.log(Number({}) == Number(!Boolean({}))) // NaN == 0 引用类型的隐式转换规则： 当引用类型的valueOf()调用时返回的值是一个基本类型时，则直接进行运算。 当引用类型的valueOf()调用时返回的值不是一个基本类型时，则引用类型的toString()将会被调用并返回转换后的字符串，然后再进行运算。 12345678// 字符串 + 数组console.log('hello' + []) // 'hello' + [].toString()// 等同于console.log('hello' + [].toString()) // 'hello' + ''// 字符串 + 对象console.log('hello' + {}) // 'hello[object Object]'// 等同于console.log('hello' + ({}).toString()) // 'hello' + '[object Object]' 案例一： 目的：验证非自定义对象的隐式转换过程 123// 申明一个对象obj1var obj1 = { age: 18 }console.log(10 + obj1) // '10[object Object]' 第一步：判断对象的valueOf()返回值是否是基本类型 12console.log(obj1.valueOf()) // { age: 18 }console.log(typeof obj1.valueOf()) // object 返回的是一个对象 第二步：调用对象的toString()返回一个表示该对象的字符串 1console.log(obj1.toString()) // '[object Object]' 第三步：根据运算规则进行运算（非字符连接操作都转换成Number进行运算） 12// 因为obj1.toString() 返回的是字符串，所以进行字符串连接操作console.log(10 + obj1.toString()) // 10 + '[object Object]' 案例二： 目的：通过自定义对象的valueOf()和toString()，来验证对象的隐式转换过程 1234567891011// 申明一个对象obj2var obj2 = { age: 18 toString: function() { return '' + this.age; }, valueOf: function() { return this.age; }}console.log(10 + obj2) // 10 + 18 = 28 第一步：判断对象的valueOf()返回值是否是基本类型 1234console.log(obj2.toString()) // '18'console.log(typeof obj2.toString()) // stringconsole.log(obj2.valueOf()) // 18console.log(typeof obj2.valueOf()) // number 第二步：如果第一步能正确返回基本类型，则直接跳到第三步，否则将调用对象的toString()返回一个表示该对象的字符串 1234// 如果对象的valueOf()返回的是基本类型console.log(10 + obj2) // 10 + obj2.valueOf()// 如果对象的valueOf()返回的是引用类型console.log(10 + obj2) // 10 + obj2.toString() 第三步：根据运算规则进行运算（非字符连接操作都转换成Number进行运算） 1234// 如果obj2的返回值是字符串，都进行字符串 VS 加号规则console.log(10 + '18') // 10 + String(obj2)// 如果obj2的返回值是非字符串，都进行数字 VS 加号规则console.log(10 + obj2) // 10 + Number(obj2) 特殊说明JavaScript中存在几个特殊的原始值：null、undefined、’’、0、NaN。 1234567891011console.log(typeof null) // objectconsole.log(null instanceof Object) // falseconsole.log(NaN == NaN) // falseconsole.log(null == undefined) // trueconsole.log(Number(null)) // 0console.log(Number(undefined)) // NaNconsole.log(0 == '') // trueconsole.log(0 == ' ') // trueconsole.log('' != ' ') //trueconsole.log(null != 0) // trueconsole.log(undefined != 0) // true 写在最后通过上面对JavaScript中的数据类型的隐式转换可以总结出以下结论： JavaScript中运算符在运算时，最终都将转换成相同类型进行运算（字符串类型、数字类型） 字符串与加号连接符运算时转换成String类型 非字符串加号连接符的运算都将转换成Number类型 特别注意引用类型的隐式转换是先判断valueOf()返回的类型，如果返回是引用类型则调用toString()返回对应的字符串值，最终都是按照1，2，3的规则进行运算。 以上内容虽然有进行验证，但不知道描述上是否存在歧义，有些点表述的不是很清楚，望谅解。 如果有发现任何问题或者有更好的建议，欢迎直接给我留言。","link":"/2019/01/28/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E7%B3%BB%E5%88%97%EF%BC%88%E7%AC%AC2%E6%9C%9F%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"title":"以“桥”的视角来聊聊前端开发模式的变迁","text":"中国是桥的故乡，自古就有“桥的国度”之称,发展于隋,兴盛于宋。遍布在神州大地的桥、编织成四通八达的交通网络，连接着祖国的四面八方。 随着经济的发展以及社会的变迁，桥缩短了人类了解自然与社会在空间和时间上的距离。在中国有太多大家耳熟能详的大桥，例如：北京卢沟桥、南京长江大桥、武汉长江大桥、杭州钱塘江大桥、深圳湾大桥、虎门大桥等等。本篇文章以“桥”为点粗略地将前端开发模式的变迁串联起来。 那么什么是桥？ 维基百科给出这样的定义：桥或桥梁是跨越峡谷、山谷、道路、铁路、河流、其他水域、或其他障碍而建造的结构，是一种由水面或地面突出来的高架，用来连着桥头桥尾两边路。 桥是一种用来跨越障碍的大型构造物。确切的说是用来将交通路线（如道路、铁路、水道等）或者其他设施（如管道、电缆等）跨越天然障碍（如河流、海峡、峡谷等）或人工障碍（高速公路、铁路线）的构造物。 背景介绍近期正在参与某移动端项目的开发，其实现方案是采用 Hybrid App（混合应用）开发模式，H5 页面端一方面通过 jsBridge 与 Native webview 进行交互实现对应的交互效果，另一方面通过 Node 中间层与 Backend 进行交互实现对数据接口的对接（如下图所示）。**在这个过程中我们把其中的一段交互方式进行抽象化且将联结着“桥头”（Native App）和“桥尾”（H5 Webpage）的中介（jsBridge）称为“桥”。** 在计算机世界里有很多这样的中介构建了无数座虚拟的“桥”，编织成四通八达的计算机信息网络，连接着各项应用程序。 本文希望通过“桥”作为切入点从前端知识体系出发取其中的三个关键词 ActiveX、Webkit、Android 来分别代表基于 IE 浏览器的网页开发以及基于近标准化的前端开发和基于智能设备的全栈开发三个不同阶段的中介，然后根据它们各自的特性以及起到的联结作用，抽象化的比喻为三座具有时代色彩的“桥”来体现前端开发模式的变迁。 本篇文章适合前端开发人员、后端开发人员、客户端开发人员、产品经理、技术经理以及所有对前端开发感兴趣的小伙伴，通过阅读该文章你会了解到如下信息： 基于 IE 浏览器的网页开发 基于近标准化的前端开发 基于智能设备的全栈开发 基于 IE 浏览器的网页开发ActiveX 是什么？ ActiveX是微软针对 Internet Explorer 开发的一个标准 COM 接口来实现对象链接与嵌入（OLE）的 ActiveX 控件。 通过 ActiveX 控件可以提供很多当时网页本身不能直接支持的功能，例如：安全密码框、在线预览 pdf、Flash 播放器、在线预览 PPT 等。 通过对 ActiveX 的了解，在该阶段我们把 ActiveX 这个中介抽象化的比喻成“桥”，并赋予一个阶段色彩的名称“古石拱桥”。 前端开发在本阶段会产生哪些变化呢？ 1. 开发工具Frontpage 网页制作、网页三剑客（Dreamweaver、Fireworks、Flash）为本人接触或使用过的最早的前端开发工具 2. 需兼容的浏览器主要是兼容 IE 浏览器或以 IE 内核为基础的第三方浏览器。 3. 遵行相关标准和规范 HTML4.01 标准+CSS2.1 规范 主要采用 Table 布局+内联样式 原生 JS 操作+Flash 动画效果 数据传递的格式主要是 XML 该阶段前端开发主要工作是负责网页制作，因此开发人员常常会被叫做页面仔。 但是该阶段后期网络环境发生了很大的变化，各项新技术得到了较快的发展，其中比较具有代表性的关键词有 Web 2.0、Ajax、Json、Flash 等。 基于近标准化的前端开发WebKit 是什么？ WebKit是一种用来让网页浏览器绘制网页的排版引擎，是著名的四大排版引擎之一。 排版引擎主要是以 Internet Explorer 为代表的 Trident 内核、以 Mozilla Firefox 为代表的 Gecko 内核、以 Opera 为代表 Presto 内核、以 Safari 和 Chrome 为代表的 WebKit 内核。 通过对 WebKit 的了解，在该阶段我们把 WebKit 这个中介抽象化的比喻成“桥”，并赋予一个阶段色彩的名称“现代摩天桥”。 前端开发在本阶段会产生哪些变化呢？ 1. 丰富的开发工具本阶段有很多的前端开发工具供选择，值得推荐的工具主要有： Sublime Text Atom Visual Studio Code WebStorm Notepad++ 2. 兼容主流浏览器 Internet Explorer Mozilla Firefox Chrome Safari Opera 3. 遵行相关标准和规范 从 XHTML1.0 过渡到 HTML5 规范 从 CSS2.1 规范过渡到 CSS3 规范 从支持 javascript 1.5 到 ES6 规范 4. 技术与框架 YUI jQuery Backbone Zepto Angular React Vue 5. 其他 正常不考虑 IE 低版本的兼容IE6 已死 优先采用 HTML5+CSS3 动画Flash 将死 …… 该阶段互联网已发展到相对繁荣阶段，前端领域也产生了大量的组件以及框架和库。 基于智能设备的全栈开发Android 是什么？ Android是一个基于 Linux 内核的开放源代码移动操作系统。其已成为全球第一大智能手机操作系统，广泛的运用于触屏移动设备。在这里我们根据大家对它的了解以及其本身的中介作用，抽象化的把称为“现代智能大桥”。 前端开发在本阶段会产生哪些变化呢？ 1. 基于多平台前端开发不仅需要基于 Windows 系统、Linux 系统、Mac 系统等桌面端操作系统的网页开发，而且还需要基于 Android 系统、Symbian 系统、iOS 系统、Windows Phone（WP）系统等移动端操作系统的网页开发。 2. 基于多端设备前端开发不再仅仅针对桌面端进行网页开发，同时也需要针对手机端、iPad 端、TV 端等多端设备进行网页开发。 3. 技术与框架 HTTP 2.0 协议 Web VR/AR PWA React Native Nodejs Typescript …… 该阶段移动互联网也已发展到相对繁荣阶段，前端相关领域得到了协同发展。前端开发将面临更多的新技术的挑战。 写在最后本文写到这里就结束了，主要是通过三个虚拟的“桥”简单的梳理了一下前端在不同阶段开式模式的改变。随着互联网的发展，未来前端的开发又会是怎么样的呢？","link":"/2017/11/17/2017-11-17-talk-about-the-past-of-front-end-development-through-bridges/"}],"tags":[{"name":"博客迁移、Jekyll、Hexo","slug":"博客迁移、Jekyll、Hexo","link":"/tags/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E3%80%81Jekyll%E3%80%81Hexo/"},{"name":"Git, Git Flow, 版本控制, 版本管理","slug":"Git-Git-Flow-版本控制-版本管理","link":"/tags/Git-Git-Flow-%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"浏览器","slug":"浏览器","link":"/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"弹窗","slug":"弹窗","link":"/tags/%E5%BC%B9%E7%AA%97/"},{"name":"拦截","slug":"拦截","link":"/tags/%E6%8B%A6%E6%88%AA/"},{"name":"window.open","slug":"window-open","link":"/tags/window-open/"},{"name":"打开新窗口","slug":"打开新窗口","link":"/tags/%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"数据类型","slug":"数据类型","link":"/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"隐式类型转换、面试题","slug":"隐式类型转换、面试题","link":"/tags/%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"javascript、一切皆对象","slug":"javascript、一切皆对象","link":"/tags/javascript%E3%80%81%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1/"},{"name":"Momentum","slug":"Momentum","link":"/tags/Momentum/"},{"name":"OneTab","slug":"OneTab","link":"/tags/OneTab/"},{"name":"Adblock Plus","slug":"Adblock-Plus","link":"/tags/Adblock-Plus/"},{"name":"chrome插件","slug":"chrome插件","link":"/tags/chrome%E6%8F%92%E4%BB%B6/"},{"name":"数据类型转换","slug":"数据类型转换","link":"/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"},{"name":"隐式转换","slug":"隐式转换","link":"/tags/%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2/"}],"categories":[{"name":"水","slug":"水","link":"/categories/%E6%B0%B4/"},{"name":"工作与生活","slug":"工作与生活","link":"/categories/%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB/"},{"name":"前端开发","slug":"前端开发","link":"/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"引用","slug":"引用","link":"/categories/%E5%BC%95%E7%94%A8/"},{"name":"培训与交流","slug":"培训与交流","link":"/categories/%E5%9F%B9%E8%AE%AD%E4%B8%8E%E4%BA%A4%E6%B5%81/"},{"name":"服务器","slug":"服务器","link":"/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"移动开发","slug":"移动开发","link":"/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"面试题","slug":"javascript/面试题","link":"/categories/javascript/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Node开发","slug":"Node开发","link":"/categories/Node%E5%BC%80%E5%8F%91/"},{"name":"版本管理","slug":"版本管理","link":"/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"},{"name":"其他","slug":"其他","link":"/categories/%E5%85%B6%E4%BB%96/"},{"name":"git常见问题","slug":"git常见问题","link":"/categories/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"name":"研发管理","slug":"研发管理","link":"/categories/%E7%A0%94%E5%8F%91%E7%AE%A1%E7%90%86/"},{"name":"前端安全","slug":"前端安全","link":"/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"},{"name":"神","slug":"神","link":"/categories/%E7%A5%9E/"},{"name":"总结","slug":"总结","link":"/categories/%E6%80%BB%E7%BB%93/"},{"name":"博客人生","slug":"博客人生","link":"/categories/%E5%8D%9A%E5%AE%A2%E4%BA%BA%E7%94%9F/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"前端进阶","slug":"前端进阶","link":"/categories/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/"},{"name":"浏览器插件","slug":"浏览器插件","link":"/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"}]}